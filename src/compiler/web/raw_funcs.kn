+func write(codes: list<[]char>, attr: []char, args: list<\ast@AstArg>, members: list<\ast@AstClassItem>)
	switch(attr)
	case "acos"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.acos(\{x.id});\n")
	case "acosh"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.log(\{x.id}+Math.sqrt(\{x.id}*\{x.id}-1));\n")
	case "addr"
		; TODO:
	case "addDict"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var key: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var item: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{meType.id}[1]===\{%array $ \convert@RuntimeTypeId $ int}&&\{meType.id}[2]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("\{me_.id}.set(\{key.id}.S, \{item.id});\n")
		do codes.add("else\n")
		do codes.add("\{me_.id}.set(\{key.id}, \{item.id});\n")
	case "addList"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let n_={P:null,N:null,I:\{item.id}};\n")
		do codes.add("if(\{me_.id}.H===null){\{me_.id}.H=n_;\{me_.id}.T=n_}else{n_.P=\{me_.id}.T;\{me_.id}.T.N=n_;\{me_.id}.T=n_}\n")
		do codes.add("\{me_.id}.L++;\n")
	case "addQueue"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("\{me_.id}.push(\{item.id});\n")
	case "addStack"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("\{me_.id}.push(\{item.id});\n")
	case "and"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}&\{n.id};\n")
	case "asin"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.asin(\{x.id});\n")
	case "asinh"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.log(\{x.id}+Math.sqrt(\{x.id}*\{x.id}+1));\n")
	case "atan"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.atan(\{x.id});\n")
	case "atanh"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return 0.5*Math.log((1+\{x.id})/(1-\{x.id}));\n")
	case "ceil"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.ceil(\{x.id});\n")
	case "cmdLine"
		do codes.add("let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\"&\");\n")
		do codes.add("if(r_.length===1&&r_[0]===\"\")return[];\n")
		do codes.add("for(let i_=0;i_<r_.length;i_++)\n")
		do codes.add("r_[i_]={S:r_[i_]};\n")
		do codes.add("return r_;\n")
	case "cos"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.cos(\{x.id});\n")
	case "cosh"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.cosh(\{x.id});\n")
	case "del"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let p_=\{me_.id}.P;\n")
		do codes.add("if(p_.P===null)\{me_.id}.H=p_.N;else p_.P.N=p_.N;\n")
		do codes.add("if(p_.N===null)\{me_.id}.T=p_.P;else p_.N.P=p_.P;\n")
		do codes.add("\{me_.id}.P=p_.N;\n")
		do codes.add("\{me_.id}.L--;\n")
	case "dist"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var y: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var centerX: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var centerY: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let x_=\{x.id}-\{centerX.id},y_=\{y.id}-\{centerY.id};\n")
		do codes.add("return Math.sqrt(x_*x_+y_*y_);\n")
	case "endian"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("switch(\{meType.id}[0]){\n")
		do codes.add("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:return \{me_.id};\n")
		do codes.add("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:return((\{me_.id}&0x00ff)<<8)|((\{me_.id}&0xff00)>>>8);\n")
		do codes.add("default:\n")
		do codes.add("\{me_.id}=((\{me_.id}&0x00ff00ff)<<8)|((\{me_.id}&0xff00ff00)>>8);\n")
		do codes.add("return ((\{me_.id}&0x0000ffff)<<16)|((\{me_.id}&0xffff0000)>>16);\n")
		do codes.add("}\n")
	case "exp"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.exp(\{x.id});\n")
	case "fill"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var value: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{meType.id}[0]===\{%array $ \convert@RuntimeTypeId $ int}&&\{meType.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("\{me_.id}.S=R_(String.fromCharCode(\{value.id}),\{me_.id}.S.length);\n")
		do codes.add("else\n")
		do codes.add("\{me_.id}.fill(\{value.id});\n")
	case "findArray"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var item: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var start: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{meType.id}[0]===\{%array $ \convert@RuntimeTypeId $ int}&&\{meType.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("return \{me_.id}.S.indexOf(String.fromCharCode(\{item.id}),\{start.id}===-1?0:\{start.id});\n")
		do codes.add("else\n")
		do codes.add("return \{me_.id}.indexOf(\{item.id},\{start.id}===-1?0:\{start.id});\n")
	case "findBin"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var item: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let a_=0,b_=\{meType.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int}?\{me_.id}.S.length-1:\{me_.id}.length-1,c_,m_,f_;\n")
		do codes.add("switch(\{meType.id}[1]){\n")
		do codes.add("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%float_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%char_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%bit32_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("f_=function(a,b){return a>b?1:a<b?-1:0};\n")
		do codes.add("break;\n")
		do codes.add("case \{%array $ \convert@RuntimeTypeId $ int}:\n") {TODO:}
		do codes.add("f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\n")
		do codes.add("break;\n")
		do codes.add("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("f_=a_<=b_?CT_[\{me_.id}[0].Y_+\{%cmp $ \convert@MethodOffset $ int}]:null;\n")
		do codes.add("break;\n")
		do codes.add("default:\n")
		; TODO:
		do codes.add("break;\n")
		do codes.add("}\n")
		do codes.add("while (a_<=b_){\n")
		do codes.add("c_=Math.floor((a_+b_)/2);\n")
		do codes.add("m_=f_(\{item.id},\{meType.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int}?\{me_.id}.S.charCodeAt(c_):\{me_.id}[c_]);\n")
		do codes.add("if(m_<0)b_=c_-1;\n")
		do codes.add("else if(m_>0)a_=c_+1;\n")
		do codes.add("else return c_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "findLastArray"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var item: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var start: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{meType.id}[0]===\{%array $ \convert@RuntimeTypeId $ int}&&\{meType.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("return \{me_.id}.S.lastIndexOf(String.fromCharCode(\{item.id}),\{start.id}===-1?\{me_.id}.S.length-1:\{start.id});\n")
		do codes.add("else\n")
		do codes.add("return \{me_.id}.lastIndexOf(\{item.id},\{start.id}===-1?\{me_.id}.S.length-1:\{start.id});\n")
	case "floor"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.floor(\{x.id});\n")
	case "forEach"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var callback: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var data: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let D_={F:\{callback.id},D:\{data.id},C:true};\n")
		do codes.add("if(\{meType.id}[1]===\{%array $ \convert@RuntimeTypeId $ int}&&\{meType.id}[2]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("\{me_.id}.forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);\n")
		do codes.add("else\n")
		do codes.add("\{me_.id}.forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);\n")
		do codes.add("return D_.C;\n")
	case "getDict"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var key: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var existed: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let r_;\n")
		do codes.add("if(\{meType.id}[1]===\{%array $ \convert@RuntimeTypeId $ int}&&\{meType.id}[2]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("r_=\{me_.id}.get(\{key.id}.S);\n")
		do codes.add("else\n")
		do codes.add("r_=\{me_.id}.get(\{key.id});\n")
		do codes.add("if(!(\{existed.id}.$=r_!==undefined)){\n")
		do codes.add("switch(DS_(\{meType.id})){\n")
		do codes.add("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%float_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%char_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%bit32_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("return 0;\n")
		do codes.add("case \{%bool_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("return false;\n")
		do codes.add("default:\n")
		do codes.add("return null;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("return r_;\n")
	case "getList"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}.P.I;\n")
	case "getQueue"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}.shift();\n")
	case "getStack"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}.pop();\n")
	case "head"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("\{me_.id}.P=\{me_.id}.H;\n")
	case "idx"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let p_=\{me_.id}.H,i_=0;\n")
		do codes.add("if(\{me_.id}.P===null)return -1;\n")
		do codes.add("while(p_!==null){\n")
		do codes.add("if(p_===\{me_.id}.P)return i_\n")
		do codes.add("i_++;\n")
		do codes.add("p_=p_.N;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "ins"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let p_=\{me_.id}.P;\n")
		do codes.add("let n_={P:p_.P,N:p_,I:\{item.id}}\n")
		do codes.add("if(p_.P===null)\{me_.id}.H=n_;else p_.P.N=n_;\n")
		do codes.add("if(\{me_.id}.T===null)\{me_.id}.T=n_;\n")
		do codes.add("p_.P=n_;\n")
		do codes.add("\{me_.id}.L++;\n")
	case "invRot"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var y: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var centerX: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var centerY: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let r_=Math.atan2(\{y.id}-\{centerY.id},\{x.id}-\{centerX.id});\n")
		do codes.add("return r_<0.0?r_+2.0*Math.PI:r_;\n")
	case "ln"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.log(\{x.id});\n")
	case "moveOffset"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var offset: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{offset.id}>=0){\n")
		do codes.add("for(let i_=0;i_<\{offset.id};i_++){\n")
		do codes.add("if(\{me_.id}.P===null)break;\n")
		do codes.add("\{me_.id}.P=\{me_.id}.P.N;\n")
		do codes.add("}\n")
		do codes.add("}else{\n")
		do codes.add("for(let i_=0;i_>\{offset.id};i_--){\n")
		do codes.add("if(\{me_.id}.P===null)break;\n")
		do codes.add("\{me_.id}.P=\{me_.id}.P.P;\n")
		do codes.add("}\n")
		do codes.add("}\n")
	case "next"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("\{me_.id}.P=\{me_.id}.P.N;\n")
	case "not"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return ~\{me_.id};\n")
	case "now"
		do codes.add("return Math.floor(new Date().getTime()/1000);\n")
	case "or"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}|\{n.id};\n")
	case "peekQueue"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}[0];\n")
	case "peekStack"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}[\{me_.id}.length-1];\n")
	case "prev"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("\{me_.id}.P=\{me_.id}.P.P;\n")
	case "reverse"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{meType.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("\{me_.id}.S=\{me_.id}.S.split(\"\").reverse().join(\"\");\n")
		do codes.add("else\n")
		do codes.add("\{me_.id}.reverse();\n")
	case "rnd"
		do args.head()
		var min: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var max: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.floor(Math.random()*(\{max.id}-\{min.id}+1))+\{min.id};\n")
	case "rndFloat"
		do args.head()
		var min: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var max: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.random()*(\{max.id}-\{min.id})+\{min.id};\n")
	case "sar"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var n: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("switch(\{meType.id}[0]){\n")
		do codes.add("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("return \{me_.id}<<24>>\{n.id}>>>24;\n")
		do codes.add("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("return \{me_.id}<<16>>\{n.id}>>>16;\n")
		do codes.add("default:\n")
		do codes.add("return \{me_.id}>>\{n.id};\n")
		do codes.add("}\n")
	case "shl"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}<<\{n.id};\n")
	case "shr"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}>>>\{n.id};\n")
	case "sin"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.sin(\{x.id});\n")
	case "sinh"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.sinh(\{x.id});\n")
	case "sortArray"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{meType.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("\{me_.id}.S=\{me_.id}.S.split(\"\").sort().join(\"\");\n")
		do codes.add("else if(\{meType.id}[1]===\{%array $ \convert@RuntimeTypeId $ int}&&\{meType.id}[2]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("\{me_.id}.sort();\n")
		do codes.add("else if(\{meType.id}[1]===\{%class_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("\{me_.id}.sort(CT_[\{me_.id}[0].Y_+\{%cmp $ \convert@MethodOffset $ int}]);\n")
		do codes.add("else\n")
		do codes.add("\{me_.id}.sort(function(a,b){return a>b?1:a<b?-1:0;});\n")
	case "sqrt"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.sqrt(\{x.id});\n")
	case "sub"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var meType: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var start: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var len: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{meType.id}[0]===\{%array $ \convert@RuntimeTypeId $ int}&&\{meType.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("return {S:\{len.id}===-1?\{me_.id}.S.slice(\{start.id}):\{me_.id}.S.slice(\{start.id},\{start.id}+\{len.id})};\n")
		do codes.add("else\n")
		do codes.add("return \{len.id}===-1?\{me_.id}.slice(\{start.id}):\{me_.id}.slice(\{start.id},\{start.id}+\{len.id});\n")
	case "sysTime"
		do codes.add("return new Date().getTime();\n")
	case "tail"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("\{me_.id}.P=\{me_.id}.T;\n")
	case "tan"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.tan(\{x.id});\n")
	case "tanh"
		do args.head()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return Math.tanh(\{x.id});\n")
	case "term"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}.P===null;\n")
	case "toArray"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let a_=new Array(\{me_.id}.L),e_=\{me_.id}.H;\n")
		do codes.add("for(let i_=0;i_<\{me_.id}.L;i_++){\n")
		do codes.add("a_[i_]=e_.I;\n")
		do codes.add("e_=e_.N;\n")
		do codes.add("}\n")
		do codes.add("return a_;\n")
	case "toBit64"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var success: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{me_.id}.S.length>=2&&\{me_.id}.S[0]===\"0\"&&\{me_.id}.S[1]===\"x\"){\n")
		do codes.add("let s_=\{me_.id}.S.slice(2),r_=Number(\{me_.id}.S);\n")
		do codes.add("\{success.id}.$=!isNaN(r_);\n")
		do codes.add("return parseInt(s_,16);\n")
		do codes.add("}else{\n")
		do codes.add("let r_=Number(\{me_.id}.S);\n")
		do codes.add("\{success.id}.$=!isNaN(r_);\n")
		do codes.add("return parseInt(\{me_.id}.S,10);\n")
		do codes.add("}\n")
	case "toFloat"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var success: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let r_=Number(\{me_.id}.S);\n")
		do codes.add("\{success.id}.$=!isNaN(r_);\n")
		do codes.add("return r_;\n")
	case "toInt"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var success: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{me_.id}.S.length>=2&&\{me_.id}.S[0]===\"0\"&&\{me_.id}.S[1]===\"x\"){\n")
		do codes.add("let s_=\{me_.id}.S.slice(2),r_=Number(\{me_.id}.S);\n")
		do codes.add("\{success.id}.$=!isNaN(r_);\n")
		do codes.add("return parseInt(s_,16);\n")
		do codes.add("}else{\n")
		do codes.add("let r_=Number(\{me_.id}.S);\n")
		do codes.add("\{success.id}.$=!isNaN(r_);\n")
		do codes.add("return parseInt(\{me_.id}.S,10);\n")
		do codes.add("}\n")
	case "toStr"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var type: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let n_;\n")
		do codes.add("switch(\{type.id}[0]){\n")
		do codes.add("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%float_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("return{S:\{me_.id}.toString(10)};\n")
		do codes.add("case \{%char_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("return{S:String.fromCharCode(\{me_.id})};\n")
		do codes.add("case \{%bool_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("return{S:\{me_.id}?\"true\":\"false\"};\n")
		do codes.add("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("n_=\{me_.id}>=0?~~\{me_.id}&0xFF:0xFF-(~\{me_.id}&0xFF);\n")
		do codes.add("return{S:\"0x\"+(\"00\"+n_.toString(16)).slice(-2).toUpperCase()};\n")
		do codes.add("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("n_=\{me_.id}>=0?~~\{me_.id}&0xFFFF:0xFFFF-(~\{me_.id}&0xFFFF);\n")
		do codes.add("return{S:\"0x\"+(\"0000\"+n_.toString(16)).slice(-4).toUpperCase()};\n")
		do codes.add("case \{%bit32_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("n_=\{me_.id}>>>0;\n")
		do codes.add("return{S:\"0x\"+(\"00000000\"+n_.toString(16)).slice(-8).toUpperCase()};\n")
		do codes.add("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("n_=\{me_.id}>>>0;\n")
		do codes.add("return{S:\"0x\"+((\{me_.id}>=0?\"0000000000000000\":\"FFFFFFFFFFFFFFFF\")+n_.toString(16)).slice(-16).toUpperCase()};\n")
		do codes.add("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
		do codes.add("if(\{type.id}[1]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do codes.add("return \{me_.id};\n")
		; TODO:
		do codes.add("}\n")
	case "xor"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("return \{me_.id}^\{n.id};\n")
	case "cui_print"
		do args.head()
		var str: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("if(\{str.id}===null)\{str.id}={S:\"(null)\"};\n")
		do codes.add("if(O_&&O_.print){O_.print(\{str.id}.S);return;}\n")
		do codes.add("console.log(\{str.id}.S);\n")
	case "file_copyFile"
		; TODO:
		do codes.add("return false;\n")
	case "file_exist"
		do args.head()
		var path: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let f_=false,p_=\{path.id}.S;\n")
		do codes.add("if(O_&&O_.readFile)f_=O_.readFile(p_)!==null;\n")
		do codes.add("if(f_===false){\n")
		do codes.add("if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\n")
		do codes.add("f_=F_(p_,false);\n")
		do codes.add("else{\n")
		; TODO:
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("return f_;\n")
	case "file_forEach"
		do args.head()
		var path: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var recursion: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var callback: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var data: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do codes.add("let f_,p_=\{path.id}.S;\n")
		do codes.add("if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\n")
		do codes.add("f_=FF_();\n")
		do codes.add("for(let i_=0;i_<f_.length;i_++){\n")
		do codes.add("if(f_[i_].slice(0,p_.length)===p_&&(\{recursion.id}||f_[i_].slice(p_.length).indexOf(\"/\")===-1)){\n")
		do codes.add("if(!\{callback.id}({S:f_[i_]},f_[i_][f_[i_].length-1]==='/',\{data.id}))return false")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("return true;\n")
	case "file_makeReader"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var path: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("let f_=null,p_=\{path.id}.S;\n")
		do codes.add("if(O_&&O_.readFile)f_=O_.readFile(p_);\n")
		do codes.add("if(f_===null){\n")
		do codes.add("if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\n")
		do codes.add("f_=F_(p_,true);\n")
		do codes.add("else{\n")
		; TODO:
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if(f_===null)return null;\n")
		do codes.add("\{me_.id}.\{handle.id}={F:f_,I:0};\n")
		do codes.add("return \{me_.id};\n")
	case "file_makeWriter"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var path: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var append: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("\{me_.id}.\{handle.id}={F:\"\",I:0,P:\{path.id}.S};\n")
		do codes.add("return \{me_.id};\n")
	case "file_readerFin"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("\{me_.id}.\{handle.id}.F=null;\n")
	case "file_readerGetPos"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("return \{me_.id}.\{handle.id}.I;\n")
	case "file_readerReadLetter"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("return \{me_.id}.\{handle.id}.F.charCodeAt(\{me_.id}.\{handle.id}.I++);\n")
	case "file_readerSetPos"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var origin: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var pos: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("\{me_.id}.\{handle.id}.I=\{pos.id};\n")
	case "file_readerTerm"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("return \{me_.id}.\{handle.id}.I>=\{me_.id}.\{handle.id}.F.length;\n")
	case "file_writerFin"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("let d_=\{me_.id}.\{handle.id}.F.replace(/\\n/g, \"\\u000D\\n\");\n")
		do codes.add("if(O_&&O_.writeFile){O_.writeFile(\{me_.id}.\{handle.id}.P,d_);return;}\n")
		do codes.add("let b_=new Blob([d_]);\n")
		do codes.add("let l_=document.createElement(\"a\");\n")
		do codes.add("l_.download=\{me_.id}.\{handle.id}.P;\n")
		do codes.add("l_.href=(URL||webkitURL).createObjectURL(b_);\n")
		do codes.add("l_.setAttribute(\"style\",\"display:none\");\n")
		do codes.add("document.body.appendChild(l_);\n")
		do codes.add("l_.click();\n")
		do codes.add("document.body.removeChild(l_);\n")
		do codes.add("\{me_.id}.\{handle.id}.F=null;\n")
	case "file_writerGetPos"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("return \{me_.id}.\{handle.id}.I;\n")
	case "file_writerSetPos"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var origin: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var pos: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("\{me_.id}.\{handle.id}.I=\{pos.id};\n")
	case "file_writerWrite"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var n: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		; TODO:
	case "file_writerWriteChar"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var n: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("if(\{me_.id}.\{handle.id}.I<\{me_.id}.\{handle.id}.F.length)\n")
		do codes.add("\{me_.id}.\{handle.id}.F=\{me_.id}.\{handle.id}.F.slice(0,\{me_.id}.\{handle.id}.I)+String.fromCharCode(\{n.id})+\{me_.id}.\{handle.id}.F.slice(\{me_.id}.\{handle.id}.I+1);\n")
		do codes.add("else{\n")
		do codes.add("\{me_.id}.\{handle.id}.F+=String.fromCharCode(\{n.id});\n")
		do codes.add("}\n")
		do codes.add("\{me_.id}.\{handle.id}.I++;\n")
	case "wnd_editBaseGetText"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("return \{me_.id}.\{handle.id}.H.value;\n")
	case "wnd_makeEditMulti"
		do args.head()
		var me_: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var parent: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var x: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var y: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var width: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var height: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var anchorX: \web\output@WebInfo :: \web\output@getInfo(args.get())
		do args.next()
		var anchorY: \web\output@WebInfo :: \web\output@getInfo(args.get())
		var handle: \web\output@WebInfo :: search(members, "handle")
		do codes.add("let h_=document.createElement(\"textarea\");\n")
		do codes.add("h_.setAttribute(\"cols\",\"\{width.id}\");\n")
		do codes.add("h_.setAttribute(\"rows\",\"\{height.id}\");\n")
		do codes.add("document.body.appendChild(c_);\n")
		do codes.add("\{me_.id}.\{handle.id}={C:c_};\n")
		do codes.add("return \{me_.id};\n")
	default
		assert false
	end switch
	
	func search(members: list<\ast@AstClassItem>, name: []char): \web\output@WebInfo
		do members.head()
		while(!members.term())
			var def: \ast@Ast :: members.get().def
			if(def.typeId = %var_ & (def $ \ast@AstVar).arg.name <>& null & (def $ \ast@AstVar).arg.name = name)
				ret \web\output@getInfo((def $ \ast@AstVar).arg)
			end if
			do members.next()
		end while
		assert false
		ret null
	end func
end func
