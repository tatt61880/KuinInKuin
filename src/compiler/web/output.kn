var funcs: queue<\ast@AstFunc>
var classes: queue<\ast@AstClass>

var uniqueId: []char
var codes: list<[]char>
var tmpVars: list<@TmpVar>
var globalVars: list<\ast@AstArg>
var localVars: list<\ast@AstArg>
var classTable: list<[]char>

+class WebInfo(\ast@HasType)
	+var id: []char
	+var breakSkipLabel: []char
	+var alreadyWritten: bool
	+var classTableOffset: int
end class

class TmpVar()
	+var identifier: []char
end class

+func output(entry: \ast@AstFunc, resFiles: list<[]char>): bool
	do @funcs :: #queue<\ast@AstFunc>
	do @funcs.add(entry)
	do @classes :: #queue<\ast@AstClass>
	
	do @uniqueId :: "a"
	do @codes :: #list<[]char>
	do @tmpVars :: #list<@TmpVar>
	do @globalVars :: #list<\ast@AstArg>
	do @localVars :: #list<\ast@AstArg>
	do @classTable :: #list<[]char>
	
	while(^@funcs > 0 | ^@classes > 0)
		while(^@funcs > 0)
			var func_: \ast@AstFunc :: @funcs.get()
			do @buildFunc(func_)
		end while
		while(^@classes > 0)
			var class_: \ast@AstClass :: @classes.get()
			do @buildClass(class_)
		end while
	end while
	
	do @write(resFiles)
	
	ret true
end func

func buildFunc(ast: \ast@AstFunc)
	var info: @WebInfo :: @getInfo(ast)
	if(info.alreadyWritten)
		ret
	end if
	do info.alreadyWritten :: true
	
	var arg: []char :: ""
	block
		var first: bool :: true
		var items: list<\ast@AstArg> :: ast.args
		do items.head()
		while(!items.term())
			var item: \ast@AstArg :: items.get()
			var info2: @WebInfo :: @getInfo(item)
			if(first)
				do first :: false
			else
				do arg :~ ","
			end if
			do arg :~ "\{info2.id}"
			if(item.name <>& null)
				do arg :~ " /*\{item.name}*/"
			end if
			do items.next()
		end while
	end block
	
	if(ast.name <>& null)
		do @codes.add("// \{ast.name}\n")
	end if
	do @codes.add("function \{info.id}(\{arg}){\n")
	
	if(ast.funcOption.and(%raw) = %raw)
		if(^ast.funcAttr = 1)
			do ast.funcAttr.head()
			var hasMembers: bool :: false
			if(^ast.args > 0)
				do ast.args.head()
				var arg2: \ast@AstArg :: ast.args.get()
				if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)
					var members: list<\ast@AstClassItem> :: (arg2.type.refItem $ \ast@AstClass).items
					do \web\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)
					do hasMembers :: true
				end if
			end if
			if(!hasMembers)
				do \web\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)
			end if
			do @codes.add("}\n")
		end if
	else
		do @codes.tail()
		var localVarPos: int :: @codes.idx()
		
		do @buildStats(ast.stats)
		
		do @codes.add("}\n")
		
		do @codes.head()
		do @codes.moveOffset(localVarPos)
		do @codes.next()
		do @localVars.head()
		while(!@localVars.term())
			var localVar: \ast@AstArg :: @localVars.get()
			var info2: @WebInfo :: @getInfo(localVar)
			if(localVar.name =& null)
				do @codes.ins("let \{info2.id};\n")
			else
				do @codes.ins("let \{info2.id}; // \{localVar.name}\n")
			end if
			do @localVars.del()
		end while
		do @tmpVars.head()
		while(!@tmpVars.term())
			var tmpVar: @TmpVar :: @tmpVars.get()
			do @codes.ins("let \{tmpVar.identifier};\n")
			do @tmpVars.del()
		end while
	end if
end func

func buildClass(ast: \ast@AstClass)
	var parentId: []char :: null
	if(ast.refItem <>& null)
		do parentId :: @refClass(ast.refItem $ \ast@AstClass)
	end if
	if(parentId =& null)
		do parentId :: "Object"
	end if
	var info: @WebInfo :: @getInfo(ast)
	if(ast.name <>& null)
		do @codes.add("// \{ast.name}\n")
	end if
	block
		var ctor: \ast@AstFunc :: findFunc(ast, "ctor")
		do @codes.add("function \{info.id}(){\n")
		do @codes.add("\{parentId}.call(this);\n")
		if(ctor <>& null)
			var ctorInfo: @WebInfo :: @getInfo(ctor)
			do @codes.add("\{ctorInfo.id}(this);\n")
		end if
		do @codes.add("}\n")
	end block
	do @codes.add("\{info.id}.prototype = Object.create(\{parentId}.prototype);\n")
	do @codes.add("\{info.id}.prototype.Y_ = \{info.classTableOffset};\n")
	block
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %var_)
				var arg: \ast@AstArg :: (item.def $ \ast@AstVar).arg
				var info2: @WebInfo :: @getInfo(arg)
				do @codes.add("\{info.id}.prototype.\{info2.id} = \{@getDefaultValue(arg.type)};\n")
			else
				assert item.def.typeId = %func_
				do @funcs.add(item.def $ \ast@AstFunc)
			end if
			do items.next()
		end while
	end block
	; TODO: Destructor.
	
	func findFunc(ast: \ast@AstClass, name: []char): \ast@AstFunc
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %func_ & item.def.name = name)
				ret item.def $ \ast@AstFunc
			end if
			do items.next()
		end while
		ret null
	end func
end func

func buildStats(stats: list<\ast@AstStat>)
	do stats.head()
	while(!stats.term())
		var stat: \ast@AstStat :: stats.get()
		switch(stat.typeId)
		case %statIf
			do @buildIf(stat $ \ast@AstStatIf)
		case %statSwitch
			do @buildSwitch(stat $ \ast@AstStatSwitch)
		case %statWhile
			do @buildWhile(stat $ \ast@AstStatWhile)
		case %statFor
			do @buildFor(stat $ \ast@AstStatFor)
		case %statTry
			do @buildTry(stat $ \ast@AstStatTry)
		case %statThrow
			do @buildThrow(stat $ \ast@AstStatThrow)
		case %statBlock
			do @buildBlock(stat $ \ast@AstStatBlock)
		case %statRet
			do @buildRet(stat $ \ast@AstStatRet)
		case %statDo
			do @buildDo(stat $ \ast@AstStatDo)
		case %statBreak
			do @buildBreak(stat $ \ast@AstStat)
		case %statSkip
			do @buildSkip(stat $ \ast@AstStat)
		case %statAssert
			do @buildAssert(stat $ \ast@AstStatAssert)
		default
			assert false
		end switch
		do stats.next()
	end while
end func

func buildIf(ast: \ast@AstStatIf)
	var infoMe: @WebInfo :: @getInfo(ast)
	if(ast.cond =& null)
		; Optimized code.
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:{\n")
		end if
		do @buildBlock(ast.statBlock)
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("}\n")
		end if
		ret
	end if
	
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:\n")
	end if
	do @codes.add("if(")
	do @buildExpr(ast.cond)
	do @codes.add("){\n")
	do @buildBlock(ast.statBlock)
	do @codes.add("}\n")
	block
		var items: list<\ast@AstStatElIf> :: ast.elIfs
		do items.head()
		while(!items.term())
			var item: \ast@AstStatElIf :: items.get()
			do @codes.add("else if(")
			do @buildExpr(item.cond)
			do @codes.add("){\n")
			do @buildBlock(item.statBlock)
			do @codes.add("}\n")
			do items.next()
		end while
	end block
	if(ast.elseStatBlock <>& null)
		do @codes.add("else{\n")
		do @buildBlock(ast.elseStatBlock)
		do @codes.add("}\n")
	end if
end func

func buildSwitch(ast: \ast@AstStatSwitch)
	var infoMe: @WebInfo :: @getInfo(ast)
	var info: @WebInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	var useSwitch: bool :: false
	if chk(\ast@isInt(ast.cond.type) | \ast@isChar(ast.cond.type) | \ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)
		do useSwitch :: true
		var items: list<\ast@AstStatCase> :: ast.cases
		do items.head()
		while(!items.term())
			var item: \ast@AstStatCase :: items.get()
			var items2: list<\ast@ExprPair> :: item.conds
			do items2.head()
			while(!items2.term())
				var exprs: \ast@ExprPair :: items2.get()
				if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)
					do useSwitch :: false
					break chk
				end if
				do items2.next()
			end while
			do items.next()
		end while
	end if
	do @codes.add("\{info.id}=")
	do @buildExpr(ast.cond)
	do @codes.add(";\n")
	if(useSwitch)
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:\n")
		end if
		do @codes.add("switch(\{info.id}){\n")
		block
			var items: list<\ast@AstStatCase> :: ast.cases
			do items.head()
			while(!items.term())
				var item: \ast@AstStatCase :: items.get()
				var items2: list<\ast@ExprPair> :: item.conds
				do items2.head()
				while(!items2.term())
					var exprs: \ast@ExprPair :: items2.get()
					assert exprs.expr1 =& null
					do @codes.add("case ")
					do @buildExpr(exprs.expr0)
					do @codes.add(":\n")
					do items2.next()
				end while
				do @buildBlock(item.statBlock)
				do @codes.add("break;\n")
				do items.next()
			end while
		end block
		if(ast.defaultStatBlock <>& null)
			do @codes.add("default:\n")
			do @buildBlock(ast.defaultStatBlock)
			do @codes.add("break;\n")
		end if
		do @codes.add("}\n")
	else
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:{\n")
		end if
		var first: bool :: true
		var items: list<\ast@AstStatCase> :: ast.cases
		do items.head()
		while(!items.term())
			var item: \ast@AstStatCase :: items.get()
			if(first)
				do first :: false
				do @codes.add("if(")
			else
				do @codes.add("else if(")
			end if
			var first2: bool :: true
			var items2: list<\ast@ExprPair> :: item.conds
			do items2.head()
			while(!items2.term())
				var exprs: \ast@ExprPair :: items2.get()
				if(first2)
					do first2 :: false
				else
					do @codes.add("||")
				end if
				if(exprs.expr1 =& null)
					if(\ast@isStr(ast.cond.type))
						do @codes.add("\{info.id}.S===(")
						do @buildExpr(exprs.expr0)
						do @codes.add(").S")
					elif(\ast@isRef(ast.cond.type))
						assert \ast@isClass(ast.cond.type)
						do @codes.add("CT_[\{info.id}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{info.id},(")
						do @buildExpr(exprs.expr0)
						do @codes.add("))===0")
					else
						do @codes.add("\{info.id}===(")
						do @buildExpr(exprs.expr0)
						do @codes.add(")")
					end if
				else
					if(\ast@isStr(ast.cond.type))
						do @codes.add("(")
						do @buildExpr(exprs.expr0)
						do @codes.add(").S<=\{info.id}.S&&\{info.id}.S<=(")
						do @buildExpr(exprs.expr1)
						do @codes.add(").S")
					elif(\ast@isRef(ast.cond.type))
						assert \ast@isClass(ast.cond.type)
						do @codes.add("CT_[\{info.id}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{info.id},(")
						do @buildExpr(exprs.expr0)
						do @codes.add("))>=0&&CT_[\{info.id}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{info.id},(")
						do @buildExpr(exprs.expr1)
						do @codes.add("))<=0")
					else
						do @codes.add("(")
						do @buildExpr(exprs.expr0)
						do @codes.add(")<=\{info.id}&&\{info.id}<=(")
						do @buildExpr(exprs.expr1)
						do @codes.add(")")
					end if
				end if
				do items2.next()
			end while
			do @codes.add("){\n")
			do @buildBlock(item.statBlock)
			do @codes.add("}\n")
			do items.next()
		end while
		if(ast.defaultStatBlock <>& null)
			if(^items = 0)
				do @codes.add("{")
			else
				do @codes.add("else{")
			end if
			do @buildBlock(ast.defaultStatBlock)
			do @codes.add("}\n")
		end if
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("}\n")
		end if
	end if
end func

func buildWhile(ast: \ast@AstStatWhile)
	var infoMe: @WebInfo :: @getInfo(ast)
	if(ast.cond =& null)
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:\n")
		end if
		do @codes.add("for(;;){\n")
		do @buildStats(ast.stats)
		do @codes.add("}\n")
		ret
	end if
	if(ast.skip_)
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:\n")
		end if
		do @codes.add("do{\n")
		do @buildStats(ast.stats)
		do @codes.add("}while(")
		do @buildExpr(ast.cond)
		do @codes.add(");\n")
		ret
	end if
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:\n")
	end if
	do @codes.add("while(")
	do @buildExpr(ast.cond)
	do @codes.add("){\n")
	do @buildStats(ast.stats)
	do @codes.add("}\n")
end func

func buildFor(ast: \ast@AstStatFor)
	var infoMe: @WebInfo :: @getInfo(ast)
	var info: @WebInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	var endId: []char :: @addTmpVar()
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:\n")
	end if
	do @codes.add("for(\{info.id}=(")
	do @buildExpr(ast.start)
	do @codes.add("),\{endId}=(")
	do @buildExpr(ast.cond)
	do @codes.add(");\{info.id}")
	assert ast.step.typeId = %exprValuePrim & \ast@isInt(ast.cond.type)
	var step: int :: (ast.step $ \ast@AstExprValuePrim).value $ int
	if(step > 0)
		do @codes.add("<=")
	else
		do @codes.add(">=")
	end if
	do @codes.add("\{endId};\{info.id}+=(")
	do @buildExpr(ast.step)
	do @codes.add(")){\n")
	do @buildStats(ast.stats)
	do @codes.add("}\n")
end func

func buildTry(ast: \ast@AstStatTry)
	var infoMe: @WebInfo :: @getInfo(ast)
	var info: @WebInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:\n")
	end if
	do @codes.add("try{\n")
	do @buildBlock(ast.statBlock)
	do @codes.add("}catch(\{info.id}){\n")
	block
		var first: bool :: true
		var items: list<\ast@AstStatCatch> :: ast.catches
		do items.head()
		while(!items.term())
			var item: \ast@AstStatCatch :: items.get()
			if(first)
				do first :: false
				do @codes.add("if(")
			else
				do @codes.add("else if(")
			end if
			var first2: bool :: true
			var items2: list<\ast@ExprPair> :: item.conds
			do items2.head()
			while(!items2.term())
				var exprs: \ast@ExprPair :: items2.get()
				if(first2)
					do first2 :: false
				else
					do @codes.add("||")
				end if
				if(exprs.expr1 =& null)
					do @codes.add("\{info.id}===(")
					do @buildExpr(exprs.expr0)
					do @codes.add(")")
				else
					do @codes.add("(")
					do @buildExpr(exprs.expr0)
					do @codes.add(")<=\{info.id}&&\{info.id}<=(")
					do @buildExpr(exprs.expr1)
					do @codes.add(")")
				end if
				do items2.next()
			end while
			do @codes.add("){\n")
			do @buildBlock(item.statBlock)
			do @codes.add("}\n")
			do items.next()
		end while
		if(first)
			do @codes.add("{\n")
		else
			do @codes.add("else{\n")
		end if
		do @codes.add("throw \{info.id};\n}\n")
	end block
	do @codes.add("}\n")
	if(ast.finallyStatBlock <>& null)
		do @codes.add("finally{\n")
		do @buildBlock(ast.finallyStatBlock)
		do @codes.add("}\n")
	end if
end func

func buildThrow(ast: \ast@AstStatThrow)
	do @codes.add("throw ")
	do @buildExpr(ast.code)
	do @codes.add(";\n")
end func

func buildBlock(ast: \ast@AstStatBlock)
	var infoMe: @WebInfo :: @getInfo(ast)
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:{\n")
	end if
	do @buildStats(ast.stats)
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("}\n")
	end if
end func

func buildRet(ast: \ast@AstStatRet)
	if(ast.value =& null)
		do @codes.add("return;\n")
	else
		do @codes.add("return ")
		do @buildExpr(ast.value)
		do @codes.add(";\n")
	end if
end func

func buildDo(ast: \ast@AstStatDo)
	do @buildExpr(ast.expr)
	do @codes.add(";\n")
end func

func buildBreak(ast: \ast@AstStat)
	assert ast.refItem.typeId.and(%statBreakable) = %statBreakable
	var info: @WebInfo :: @getInfo(ast.refItem)
	do @codes.add("break \{info.breakSkipLabel};\n")
end func

func buildSkip(ast: \ast@AstStat)
	assert ast.refItem.typeId.and(%statSkipable) = %statSkipable
	var info: @WebInfo :: @getInfo(ast.refItem)
	do @codes.add("continue \{info.breakSkipLabel};\n")
end func

func buildAssert(ast: \ast@AstStatAssert)
	do @codes.add("if(!(")
	do @buildExpr(ast.cond)
	do @codes.add(")){throw \{excpt@dbgAssertFailed $ bit32};}\n")
end func

func buildExpr(ast: \ast@AstExpr)
	switch(ast.typeId)
	case %expr1
		do @buildExpr1(ast $ \ast@AstExpr1)
	case %expr2
		do @buildExpr2(ast $ \ast@AstExpr2)
	case %expr3
		do @buildExpr3(ast $ \ast@AstExpr3)
	case %exprNew
		do @buildExprNew(ast $ \ast@AstExprNew)
	case %exprNewArray
		do @buildExprNewArray(ast $ \ast@AstExprNewArray)
	case %exprAs
		do @buildExprAs(ast $ \ast@AstExprAs)
	case %exprToBin
		do @buildExprToBin(ast $ \ast@AstExprToBin)
	case %exprFromBin
		do @buildExprFromBin(ast $ \ast@AstExprFromBin)
	case %exprCall
		do @buildExprCall(ast $ \ast@AstExprCall)
	case %exprArray
		do @buildExprArray(ast $ \ast@AstExprArray)
	case %exprDot
		do @buildExprDot(ast $ \ast@AstExprDot)
	case %exprValue
		do @buildExprValue(ast $ \ast@AstExprValue)
	case %exprValuePrim
		do @buildExprValuePrim(ast $ \ast@AstExprValuePrim)
	case %exprValueStr
		do @buildExprValueStr(ast $ \ast@AstExprValueStr)
	case %exprValueFloat
		do @buildExprValueFloat(ast $ \ast@AstExprValueFloat)
	case %exprValueArray
		do @buildExprValueArray(ast $ \ast@AstExprValueArray)
	case %exprRef
		do @buildExprRef(ast $ \ast@AstExpr)
	default
		assert false
	end switch
end func

func buildExpr1(ast: \ast@AstExpr1)
	assert ast.varKind <> %unknown
	switch(ast.kind)
	case %plus
		do @buildExpr(ast.child)
	case %minus
		do @codes.add("-(")
		do @buildExpr(ast.child)
		do @codes.add(")")
	case %not
		do @codes.add("!(")
		do @buildExpr(ast.child)
		do @codes.add(")")
	case %copy
		var typeId: []char :: @makeTypeId(ast.child.type)
		do @codes.add("C_(\{typeId},(")
		do @buildExpr(ast.child)
		do @codes.add("))")
	case %len
		var type: \ast@AstType :: ast.child.type
		if(type.typeId = %typeGen)
			switch((type $ \ast@AstTypeGen).kind)
			case %list_
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").L")
			case %stack_
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").length")
			case %queue_
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").length")
			default
				assert false
			end switch
		elif(type.typeId = %typeDict)
			do @codes.add("(")
			do @buildExpr(ast.child)
			do @codes.add(").size")
		else
			assert type.typeId = %typeArray
			if(\ast@isChar((type $ \ast@AstTypeArray).itemType))
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").S.length")
			else
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").length")
			end if
		end if
	default
		assert false
	end switch
end func

func buildExpr2(ast: \ast@AstExpr2)
	assert ast.varKind <> %unknown
	var type: \ast@AstType :: ast.children0.type
	switch(ast.kind)
	case %assign
		if(ast.children0.typeId = %exprArray & \ast@isChar((ast.children0 $ \ast@AstExprArray).type))
			var ast2: \ast@AstExprArray :: ast.children0 $ \ast@AstExprArray
			var tmpIdx: []char :: @addTmpVar()
			var tmpChar: []char :: @addTmpVar()
			do @codes.add("(")
			do @buildExpr(ast2.var_)
			do @codes.add(").S=(\{tmpIdx}=(")
			do @buildExpr(ast2.idx)
			do @codes.add("),(")
			do @buildExpr(ast2.var_)
			do @codes.add(").S.slice(0,\{tmpIdx})+String.fromCharCode(")
			do @buildExpr(ast.children1)
			do @codes.add(")+(")
			do @buildExpr(ast2.var_)
			do @codes.add(").S.slice(\{tmpIdx}+1))")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")=(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %or
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")||(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %and
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")&&(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %lt
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S<(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			assert \ast@isClass(type)
			var tmp: []char :: @addTmpVar()
			do @codes.add("\{tmp}=(")
			do @buildExpr(ast.children0)
			do @codes.add("),CT_[\{tmp}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{tmp},(")
			do @buildExpr(ast.children1)
			do @codes.add("))<0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")<(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %gt
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S>(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			assert \ast@isClass(type)
			var tmp: []char :: @addTmpVar()
			do @codes.add("\{tmp}=(")
			do @buildExpr(ast.children0)
			do @codes.add("),CT_[\{tmp}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{tmp},(")
			do @buildExpr(ast.children1)
			do @codes.add("))>0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")>(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %le
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S<=(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			assert \ast@isClass(type)
			var tmp: []char :: @addTmpVar()
			do @codes.add("\{tmp}=(")
			do @buildExpr(ast.children0)
			do @codes.add("),CT_[\{tmp}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{tmp},(")
			do @buildExpr(ast.children1)
			do @codes.add("))<=0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")<=(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %ge
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S>=(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			assert \ast@isClass(type)
			var tmp: []char :: @addTmpVar()
			do @codes.add("\{tmp}=(")
			do @buildExpr(ast.children0)
			do @codes.add("),CT_[\{tmp}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{tmp},(")
			do @buildExpr(ast.children1)
			do @codes.add("))>=0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")>=(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %eq
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S===(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			assert \ast@isClass(type)
			var tmp: []char :: @addTmpVar()
			do @codes.add("\{tmp}=(")
			do @buildExpr(ast.children0)
			do @codes.add("),CT_[\{tmp}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{tmp},(")
			do @buildExpr(ast.children1)
			do @codes.add("))===0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")===(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %nEq
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S!==(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			assert \ast@isClass(type)
			var tmp: []char :: @addTmpVar()
			do @codes.add("\{tmp}=(")
			do @buildExpr(ast.children0)
			do @codes.add("),CT_[\{tmp}.Y_+\{%cmp $ \convert@MethodOffset $ int}](\{tmp},(")
			do @buildExpr(ast.children1)
			do @codes.add("))!==0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")!==(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %eqRef
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")===(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %nEqRef
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")!==(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %cat
		if(\ast@isStr(type))
			do @codes.add("{S:(")
			do @buildExpr(ast.children0)
			do @codes.add(").S+(")
			do @buildExpr(ast.children1)
			do @codes.add(").S}")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").concat(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %add
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")+(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %sub
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")-(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %mul
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")*(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %div
		if(!\ast@isFloat(type))
			do @codes.add("Math.floor(")
		end if
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")/(")
		do @buildExpr(ast.children1)
		if(!\ast@isFloat(type))
			do @codes.add("))")
		else
			do @codes.add(")")
		end if
	case %mod
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")%(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %pow
		do @codes.add("Math.pow((")
		do @buildExpr(ast.children0)
		do @codes.add("),(")
		do @buildExpr(ast.children1)
		do @codes.add("))")
	case %swap
		var tmpVar: []char :: @addTmpVar()
		do @codes.add("\{tmpVar}=(")
		do @buildExpr(ast.children0)
		do @codes.add("),(")
		do @buildExpr(ast.children0)
		do @codes.add(")=(")
		do @buildExpr(ast.children1)
		do @codes.add("),(")
		do @buildExpr(ast.children1)
		do @codes.add(")=(\{tmpVar})")
	default
		assert false
	end switch
end func

func buildExpr3(ast: \ast@AstExpr3)
	assert ast.varKind <> %unknown
	do @codes.add("(")
	do @buildExpr(ast.children0)
	do @codes.add(")?(")
	do @buildExpr(ast.children1)
	do @codes.add("):(")
	do @buildExpr(ast.children2)
	do @codes.add(")")
end func

func buildExprNew(ast: \ast@AstExprNew)
	assert ast.varKind <> %unknown
	if(\ast@isClass(ast.itemType))
		var class_: \ast@AstClass :: ast.itemType.refItem $ \ast@AstClass
		var id: []char :: @refClass(class_)
		do @codes.add("new \{id}()")
	else
		if(ast.itemType.typeId = %typeGen)
			var gen: \ast@AstTypeGen :: ast.itemType $ \ast@AstTypeGen
			switch(gen.kind)
			case %list_
				do @codes.add("{L:0,H:null,T:null,P:null}")
			case %stack_
				do @codes.add("[]")
			case %queue_
				do @codes.add("[]")
			default
				assert false
			end switch
		else
			assert ast.itemType.typeId = %typeDict
			do @codes.add("new Map()")
		end if
	end if
end func

func buildExprNewArray(ast: \ast@AstExprNewArray)
	assert ast.varKind <> %unknown
	block
		var items: list<\ast@AstExpr> :: ast.idces
		do items.head()
		if(\ast@isChar(ast.itemType))
			if(^items = 1)
				do @codes.add("{S:R_(\"\\0\",(")
				do @buildExpr(items.get())
				do @codes.add("))}")
			else
				do @codes.add("(function A_(n){if(n.length===1)return{S:R_(\"\\0\",n[0])};else{let m=n.shift(),a=new Array(m),i;for(i=0;i<m;i++)a[i]=A_(n);return a;}})([")
				var first: bool :: true
				while(!items.term())
					if(first)
						do first :: false
						do @codes.add("(")
					else
						do @codes.add(",(")
					end if
					do @buildExpr(items.get())
					do @codes.add(")")
					do items.next()
				end while
				do @codes.add("])")
			end if
		else
			if(^items = 1)
				do @codes.add("new Array(")
				do @buildExpr(items.get())
				do @codes.add(").fill(\{@getDefaultValue(ast.itemType)})")
			else
				do @codes.add("(function A_(n){if(n.length===1)return new Array(n[0]).fill(\{@getDefaultValue(ast.itemType)});else{let m=n.shift(),a=new Array(m),i;for(i=0;i<m;i++)a[i]=A_(n);return a}})([")
				var first: bool :: true
				while(!items.term())
					if(first)
						do first :: false
					else
						do @codes.add(",(")
					end if
					do @buildExpr(items.get())
					do @codes.add(")")
					do items.next()
				end while
				do @codes.add("])")
			end if
		end if
	end block
end func

func buildExprAs(ast: \ast@AstExprAs)
	assert ast.varKind <> %unknown
	switch(ast.kind)
	case %as
		var t1: \ast@AstType :: ast.child.type
		var t2: \ast@AstType :: ast.childType
		if(\ast@isClass(t1))
			assert \ast@isClass(t2)
			do @refClass(t2.refItem $ \ast@AstClass)
			do @buildExpr(ast.child)
		else
			if(t1.typeId = %typeBit | \ast@isInt(t1) | \ast@isChar(t1) | \ast@isEnum(t1))
				if(t2.typeId = %typeBit | \ast@isInt(t2) | \ast@isChar(t2) | \ast@isEnum(t2) | \ast@isFloat(t2))
					do @buildExpr(ast.child)
				else
					assert \ast@isBool(t2)
					do @codes.add("(")
					do @buildExpr(ast.child)
					do @codes.add(")!=0")
				end if
			elif(\ast@isFloat(t1))
				if(t2.typeId = %typeBit | \ast@isInt(t2))
					do @codes.add("Math.floor(")
					do @buildExpr(ast.child)
					do @codes.add(")")
				else
					assert \ast@isFloat(t2)
					do @buildExpr(ast.child)
				end if
			else
				assert \ast@isBool(t1)
				if(t2.typeId = %typeBit | \ast@isInt(t2))
					do @codes.add("(")
					do @buildExpr(ast.child)
					do @codes.add(")?1:0")
				else
					assert \ast@isBool(t2)
					do @buildExpr(ast.child)
				end if
			end if
		end if
	case %is
		do @refClass(ast.childType.refItem $ \ast@AstClass)
		var info: @WebInfo :: @getInfo(ast.childType.refItem)
		do @codes.add("(")
		do @buildExpr(ast.child)
		do @codes.add(")instanceof \{info.id}")
	case %nIs
		do @refClass(ast.childType.refItem $ \ast@AstClass)
		var info: @WebInfo :: @getInfo(ast.childType.refItem)
		do @codes.add("!((")
		do @buildExpr(ast.child)
		do @codes.add(")instanceof \{info.id})")
	default
		assert false
	end switch
end func

func buildExprToBin(ast: \ast@AstExprToBin)
	assert ast.varKind <> %unknown
	do @codes.add("TB_(\{@makeTypeId(ast.child.type)},(")
	do @buildExpr(ast.child)
	do @codes.add("))")
end func

func buildExprFromBin(ast: \ast@AstExprFromBin)
	assert ast.varKind <> %unknown
	if(ast.offset.typeId.and(%exprValue) = %exprValue)
		do @codes.add("FB_(\{@makeTypeId(ast.childType)},(")
		do @buildExpr(ast.child)
		do @codes.add("),{$:(")
		do @buildExpr(ast.offset)
		do @codes.add(")})")
	else
		var tmp: []char :: @addTmpVar()
		var result: []char :: @addTmpVar()
		do @codes.add("\{result}=FB_(\{@makeTypeId(ast.childType)},(")
		do @buildExpr(ast.child)
		do @codes.add("),(\{tmp}={$:(")
		do @buildExpr(ast.offset)
		do @codes.add(")},\{tmp})),(")
		do @buildExpr(ast.offset)
		do @codes.add(")=\{tmp}.$,\{result}")
	end if
end func

func buildExprCall(ast: \ast@AstExprCall)
	assert ast.varKind <> %unknown
	var funcType: \ast@AstTypeFunc :: ast.func_.type $ \ast@AstTypeFunc
	var meTypeId: []char :: null
	if(funcType <>& null & funcType.funcOption.and(%any) = %any)
		var items: list<\ast@AstExprCallArg> :: ast.args
		do items.head()
		do meTypeId :: @makeTypeId(items.get().arg.type)
	end if
	var refNum: int :: 0
	block
		var items: list<\ast@AstExprCallArg> :: ast.args
		do items.head()
		while(!items.term())
			if(items.get().refVar)
				do refNum :+ 1
			end if
			do items.next()
		end while
	end block
	var resultVar: []char :: null
	var refVar: [][]char :: null
	if(refNum > 0)
		do @codes.add("(")
		if(ast.type <>& null)
			do resultVar :: @addTmpVar()
			do @codes.add("\{resultVar}=")
		end if
		do refVar :: #[refNum][]char
	end if
	do @codes.add("(")
	do @buildExpr(ast.func_)
	do @codes.add(")(")
	block
		var idx: int :: 0
		var refCnt: int :: 0
		var first: bool :: true
		var items: list<\ast@AstExprCallArg> :: ast.args
		do items.head()
		while(!items.term())
			var item: \ast@AstExprCallArg :: items.get()
			if(first)
				do first :: false
				do @codes.add("(")
			else
				do @codes.add(",(")
			end if
			if(meTypeId <>& null & idx = 1)
				do @codes.add(meTypeId)
			elif(item.refVar)
				do refVar[refCnt] :: @addTmpVar()
				do @codes.add("\{refVar[refCnt]}={$:(")
				if(item.skipVar)
					do @codes.add(@getDefaultValue(item.arg.type))
				else
					do @buildExpr(item.arg)
				end if
				do @codes.add(")},\{refVar[refCnt]}")
				do refCnt :+ 1
			else
				do @buildExpr(item.arg)
			end if
			do @codes.add(")")
			do idx :+ 1
			do items.next()
		end while
	end block
	do @codes.add(")")
	if(refNum > 0)
		block
			var idx: int :: 0
			var refCnt: int :: 0
			var items: list<\ast@AstExprCallArg> :: ast.args
			do items.head()
			while(!items.term())
				var item: \ast@AstExprCallArg :: items.get()
				if(meTypeId <>& null & idx = 1)
					; Do nothing.
				elif(item.refVar)
					do @codes.add(",(")
					do @buildExpr(item.arg)
					do @codes.add(")=\{refVar[refCnt]}.$")
					do refCnt :+ 1
				end if
				do idx :+ 1
				do items.next()
			end while
		end block
		if(ast.type <>& null)
			do @codes.add(",\{resultVar}")
		end if
		do @codes.add(")")
	end if
	
	block
		var type: \ast@AstType :: ast.type
		if(type <>& null)
			if(\ast@isClass(type))
				do @refClass(type.refItem $ \ast@AstClass)
			end if
		end if
	end block
end func

func buildExprArray(ast: \ast@AstExprArray)
	assert ast.varKind <> %unknown
	if(\ast@isChar(ast.type))
		do @codes.add("(")
		do @buildExpr(ast.var_)
		do @codes.add(").S.charCodeAt(")
		do @buildExpr(ast.idx)
		do @codes.add(")")
	else
		do @codes.add("(")
		do @buildExpr(ast.var_)
		do @codes.add(")[")
		do @buildExpr(ast.idx)
		do @codes.add("]")
	end if
end func

func buildExprDot(ast: \ast@AstExprDot)
	assert ast.varKind <> %unknown
	if(\ast@isClass(ast.var_.type))
		var classItem: \ast@AstClassItem :: ast.classItem
		assert classItem <>& null
		do @refClass(ast.var_.type.refItem $ \ast@AstClass)
		var info: @WebInfo
		if(classItem.def.typeId = %var_)
			do info :: @getInfo((classItem.def $ \ast@AstVar).arg)
			do @codes.add("(")
			do @buildExpr(ast.var_)
			do @codes.add(").\{info.id}")
		else
			assert classItem.def.typeId = %func_
			do info :: @getInfo(classItem.def)
			do @codes.add("CT_[(")
			do @buildExpr(ast.var_)
			do @codes.add(").Y_ + \{info.classTableOffset}]")
		end if
	else
		assert ast.refItem.typeId = %exprRef
		do @buildExprRef(ast.refItem $ \ast@AstExpr)
	end if
end func

func buildExprValue(ast: \ast@AstExprValue)
	assert ast.type.typeId = %typeNull
	do @codes.add("null")
end func

func buildExprValuePrim(ast: \ast@AstExprValuePrim)
	var type: \ast@AstType :: ast.type
	if(\ast@isInt(type) | \ast@isEnum(type))
		do @codes.add((ast.value $ int).toStr())
	elif(\ast@isChar(type))
		do @codes.add((ast.value $ bit16).toStr())
	elif(\ast@isBool(type))
		do @codes.add(ast.value = 0b64 ?("false", "true"))
	elif(type.typeId = %typeBit)
		switch((type $ \ast@AstTypeBit).size)
		case 1
			do @codes.add((ast.value $ bit8).toStr())
		case 2
			do @codes.add((ast.value $ bit16).toStr())
		case 4
			do @codes.add((ast.value $ bit32).toStr())
		case 8
			do @codes.add((ast.value $ bit64).toStr())
		default
			assert false
		end switch
	else
		assert false
	end if
end func

func buildExprValueStr(ast: \ast@AstExprValueStr)
	var value: []char :: ast.value
	var s: []char :: "{S:\""
	for i(0, ^value - 1)
		do s :~ @escapeChar(value[i])
	end for
	do s :~ "\"}"
	do @codes.add(s)
end func

func buildExprValueFloat(ast: \ast@AstExprValueFloat)
	var value: []char :: ast.value.toStr()
	if(value = "inf")
		do @codes.add("Infinity")
	else
		do @codes.add(value)
	end if
end func

func buildExprValueArray(ast: \ast@AstExprValueArray)
	; Note that constant string values are handled by 'ExprValueStr'.
	if(\ast@isStr(ast.type))
		do @codes.add("{S:String.fromCharCode(")
		var first: bool :: true
		var items: list<\ast@AstExpr> :: ast.values
		do items.head()
		while(!items.term())
			if(first)
				do first :: false
				do @codes.add("(")
			else
				do @codes.add(",(")
			end if
			do @buildExpr(items.get())
			do @codes.add(")")
			do items.next()
		end while
		do @codes.add(")}")
		ret
	end if
	
	do @codes.add("[")
	var first: bool :: true
	var items: list<\ast@AstExpr> :: ast.values
	do items.head()
	while(!items.term())
		if(first)
			do first :: false
			do @codes.add("(")
		else
			do @codes.add(",(")
		end if
		do @buildExpr(items.get())
		do @codes.add(")")
		do items.next()
	end while
	do @codes.add("]")
end func

func buildExprRef(ast: \ast@AstExpr)
	var ast2: \ast@Ast :: ast.refItem
	var info: @WebInfo :: @getInfo(ast2)
	if(ast2.typeId = %func_)
		do @funcs.add(ast2 $ \ast@AstFunc)
		do @codes.add(info.id)
	else
		assert ast2.typeId = %arg
		var arg: \ast@AstArg :: ast2 $ \ast@AstArg
		switch(arg.kind)
		case %global
			if(!info.alreadyWritten)
				do info.alreadyWritten :: true
				do @globalVars.add(arg)
			end if
		case %localArg
			; Do nothing.
		case %localVar
			if(!info.alreadyWritten)
				do info.alreadyWritten :: true
				do @localVars.add(arg)
			end if
		default
			assert false
		end switch
		if(arg.refVar)
			do @codes.add("\{info.id}.$")
		else
			do @codes.add(info.id)
		end if
	end if
end func

func write(resFiles: list<[]char>)
	var writer: file@Writer
	if(\option@extra.get("merge", &))
		var fileName: []char :: file@fileName(\option@outputFile)
		do writer :: file@makeWriter(\option@outputFile ~ ".html", false)
		do writer.writeStr("<!DOCTYPE html>\n")
		do writer.writeStr("<html>\n")
		do writer.writeStr("\t<head>\n")
		do writer.writeStr("\t\t<meta charset=\"utf-8\" />\n")
		do writer.writeStr("\t\t<title>\{fileName}</title>\n")
		do writer.writeStr("\t\t<script type=\"text/javascript\">\n")
		do writeJs(writer, resFiles)
		do writer.writeStr("\t\t</script>\n")
		do writer.writeStr("\t</head>\n")
		do writer.writeStr("\t<body>\n")
		do writer.writeStr("\t</body>\n")
		do writer.writeStr("</html>\n")
		do writer.fin()
	else
		do writer :: file@makeWriter(\option@outputFile ~ ".js", false)
		do writeJs(writer, resFiles)
		do writer.fin()
		
		var fileName: []char :: file@fileName(\option@outputFile)
		do writer :: file@makeWriter(\option@outputFile ~ ".html", false)
		do writer.writeStr("<!DOCTYPE html>\n")
		do writer.writeStr("<html>\n")
		do writer.writeStr("\t<head>\n")
		do writer.writeStr("\t\t<meta charset=\"utf-8\" />\n")
		do writer.writeStr("\t\t<script src=\"\{fileName}.js\" type=\"text/javascript\"></script>\n")
		do writer.writeStr("\t\t<title>\{fileName}</title>\n")
		do writer.writeStr("\t</head>\n")
		do writer.writeStr("\t<body>\n")
		do writer.writeStr("\t</body>\n")
		do writer.writeStr("</html>\n")
		do writer.fin()
	end if
	
	func writeJs(writer: file@Writer, resFiles: list<[]char>)
		var static: bool :: \option@extra.get("static", &)
		if(static)
			do writer.writeStr("\"use strict\";function \{file@fileName(\option@outputFile)}(O_){\n")
		else
			do writer.writeStr("\"use strict\";!function(f){let d=document;function h(){d.removeEventListener(\"DOMContentLoaded\",h);removeEventListener(\"load\",h);f()}\"complete\"===d.readyState||\"loading\"!==d.readyState&&!d.documentElement.doScroll?setTimeout(f):(d.addEventListener(\"DOMContentLoaded\",h),addEventListener(\"load\",h))}(function(){\n")
			do writer.writeStr("let O_;\n")
		end if
		
		if(^@classTable <> 0)
			do writer.writeStr("let CT_ = new Array(\{^@classTable});\n")
		end if
		
		do @globalVars.head()
		while(!@globalVars.term())
			var globalVar: \ast@AstArg :: @globalVars.get()
			var info: @WebInfo :: @getInfo(globalVar)
			do writer.writeStr("let \{info.id}=\{@getDefaultValue(globalVar.type)};\n")
			do @globalVars.next()
		end while
		do @codes.head()
		while(!@codes.term())
			do writer.writeStr(@codes.get())
			do @codes.next()
		end while
		
		do writer.writeStr("function DT_(t){\n")
		do writer.writeStr("switch(t){\n")
		do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("return DT_(t.slice(1));\n")
		do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("return DT_(DT_(t.slice(1)));\n")
		do writer.writeStr("default:\n")
		do writer.writeStr("return t.slice(1);\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		
		do writer.writeStr("function TB_(t,v){\n")
		do writer.writeStr("function l(n){return[n&0xff,(n>>8)&0xff,(n>>16)&0xff,(n>>24)&0xff];}\n")
		do writer.writeStr("switch(t[0]){\n")
		do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("if(t[1]===\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
		do writer.writeStr("if(v===null)return l(-1);\n")
		do writer.writeStr("let w=v.S,r=l(w.length),c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<w.length;i++)r=r.concat(TB_(c,w[i]));\n")
		do writer.writeStr("return r;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("if(v===null)return l(-1);\n")
		do writer.writeStr("let r=l(v.length),c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<v.length;i++)r=r.concat(TB_(c,v[i]));\n")
		do writer.writeStr("return r;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("if(v===null)return l(-1);\n")
		do writer.writeStr("let p=v.H,n,i=0;\n")
		do writer.writeStr("while(p!==null){\n")
		do writer.writeStr("if(p===v.P){n=i;break;}")
		do writer.writeStr("p=p.N;i++;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("let r=l(n).concat(l(v.L)),c=t.slice(1);\n")
		do writer.writeStr("p=v.H;while(p!==null){r=r.concat(TB_(c,p.I));p=p.N;}\n")
		do writer.writeStr("return r;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("if(v===null)return l(-1);\n")
		do writer.writeStr("let r=l(v.size),p=t.slice(1),q=DT_(p);\n")
		do writer.writeStr("if(t[1]===\{%array $ \convert@RuntimeTypeId $ int}&&t[2]===\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
		do writer.writeStr("v.forEach(function(w,k){r=r.concat(TB_(p,{S:k}),TB_(q,w));});\n")
		do writer.writeStr("}else{\n")
		do writer.writeStr("v.forEach(function(w,k){r=r.concat(TB_(p,k),TB_(q,w));});\n")
		do writer.writeStr("}\n")
		do writer.writeStr("return r;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("if(v===null)return l(-1);\n")
		do writer.writeStr("return l(v.Y_).concat(CT_[v.Y_+\{%toBin $ \convert@MethodOffset $ int}](v));\n")
		do writer.writeStr("default:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("let s=v.toString(),r=new Array(s.length*2),c;\n")
		do writer.writeStr("for(let i=0;i<s.length;i++){c=s.charCodeAt(i);r[i*2]=c&0xff;r[i*2+1]=(c>>8)&0xff;}\n")
		do writer.writeStr("return l(s.length).concat(r);\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		
		do writer.writeStr("function FB_(t,b,o){\n")
		do writer.writeStr("function l(b,o){let r=b[o.$]|(b[o.$+1]<<8)|(b[o.$+2]<<16)|(b[o.$+3]<<24);o.$+=4;return r;}\n")
		do writer.writeStr("switch(t[0]){\n")
		do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("let n=l(b,o);if(n===-1)return null;\n")
		do writer.writeStr("if(t[1]===\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
		do writer.writeStr("let r=\"\",c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<n;i++)r+=FB_(c,b,o);\n")
		do writer.writeStr("return{S:r};\n")
		do writer.writeStr("}else{\n")
		do writer.writeStr("let r=new Array(n),c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<n;i++)r[i]=FB_(c,b,o);\n")
		do writer.writeStr("return r;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("let p=l(b,o),n=l(b,o);if(n===-1)return null;\n")
		do writer.writeStr("let r={L:n,H:null,T:null,P:null},c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<n;i++){\n")
		do writer.writeStr("let m={P:null,N:null,I:FB_(c,b,o)};\n")
		do writer.writeStr("if(r.H===null){r.H=m;r.T=m;}else{m.P=r.T;r.T.N=m;r.T=m;}\n")
		do writer.writeStr("if(i===p)r.P=m;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("return r;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("let n=l(b,o);if(n===-1)return null;\n")
		do writer.writeStr("let r=[],c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<n;i++)r.push(FB_(c,b,o));\n")
		do writer.writeStr("return r;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("let n=l(b,o);if(n===-1)return null;\n")
		do writer.writeStr("let r=new Map(),p=t.slice(1),q=DT_(p);\n")
		do writer.writeStr("if(t[1]===\{%array $ \convert@RuntimeTypeId $ int}&&t[2]===\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
		do writer.writeStr("for(let i=0;i<n;i++)r.set(FB_(p,b,o).S,FB_(q,b,o));\n")
		do writer.writeStr("}else{\n")
		do writer.writeStr("for(let i=0;i<n;i++)r.set(FB_(p,b,o),FB_(q,b,o));\n")
		do writer.writeStr("}\n")
		do writer.writeStr("return r;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("let y=l(b,o);if(y===-1)return null;\n")
		do writer.writeStr("return CT_[y+\{%fromBin $ \convert@MethodOffset $ int}](null,b,o);\n")
		do writer.writeStr("}\n")
		do writer.writeStr("default:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("let n=l(b,o),s=\"\";\n")
		do writer.writeStr("for(let i=0;i<n;i++){s+=String.fromCharCode(b[o.$]|(b[o.$+1]<<8));o.$+=2;}\n")
		do writer.writeStr("switch(t[0]){\n")
		do writer.writeStr("case \{%float_ $ \convert@RuntimeTypeId $ int}:return parseFloat(s);\n")
		do writer.writeStr("case \{%char_ $ \convert@RuntimeTypeId $ int}:return s;\n")
		do writer.writeStr("case \{%bool_ $ \convert@RuntimeTypeId $ int}:return s===\"true\";\n")
		do writer.writeStr("default:return parseInt(s);\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		
		do writer.writeStr("function C_(t,v){\n")
		do writer.writeStr("switch(t[0]){\n")
		do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("if(t[1]===\{%char_ $ \convert@RuntimeTypeId $ int})\n")
		do writer.writeStr("return v===null?null:{S:v.S};\n")
		do writer.writeStr("else{\n")
		do writer.writeStr("let a=new Array(v.length),c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<v.length;i++)a[i]=C_(c,v[i]);\n")
		do writer.writeStr("return a;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("if(v===null)return null;\n")
		do writer.writeStr("let l={L:v.L,H:null,T:null,P:null},p=v.H,c=t.slice(1);\n")
		do writer.writeStr("while(p!==null){\n")
		do writer.writeStr("let n={P:null,N:null,I:C_(c,p.I)};\n")
		do writer.writeStr("if(l.H===null){l.H=n;l.T=n;}else{n.P=l.T;l.T.N=n;l.T=n;}\n")
		do writer.writeStr("if(p===v.P)l.P=n;\n")
		do writer.writeStr("p=p.N;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("return l;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("if(v===null)return null;\n")
		do writer.writeStr("let s=new Array(v.length),c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<v.length;i++)s[i]=C_(c,v[i]);\n")
		do writer.writeStr("return s;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("if(v===null)return null;\n")
		do writer.writeStr("let q=new Array(v.length),c=t.slice(1);\n")
		do writer.writeStr("for(let i=0;i<v.length;i++)q[i]=C_(c,v[i]);\n")
		do writer.writeStr("return q;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("{\n")
		do writer.writeStr("if(v===null)return null;\n")
		do writer.writeStr("let d=new Map(),p=t.slice(1),q=DT_(p);\n")
		do writer.writeStr("if(t[1]===\{%array $ \convert@RuntimeTypeId $ int}&&t[2]===\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
		do writer.writeStr("v.forEach(function(w,k){this.set(C_(p,{S:k}).S,C_(q,w));},d);\n")
		do writer.writeStr("}else{\n")
		do writer.writeStr("v.forEach(function(w,k){this.set(C_(p,k),C_(q,w));},d);\n")
		do writer.writeStr("}\n")
		do writer.writeStr("return d;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
		do writer.writeStr("if(v===null)return null;\n")
		do writer.writeStr("return CT_[v.Y_+\{%copy $ \convert@MethodOffset $ int}](v);\n")
		do writer.writeStr("default:\n")
		do writer.writeStr("return v;\n")
		do writer.writeStr("}\n")
		do writer.writeStr("}\n")
		
		do writer.writeStr("function F_(p,f){\n")
		block
			var first: bool :: true
			do resFiles.head()
			while(!resFiles.term())
				var resFile: []char :: resFiles.get()
				if(first)
					do first :: false
					do writer.writeStr("if(p===\"")
				else
					do writer.writeStr("else if(p===\"")
				end if
				for i(^\option@inputDir, ^resFile - 1)
					do writer.writeStr(@escapeChar(resFile[i]))
				end for
				do writer.writeStr("\")\n")
				if(resFile[^resFile - 1] = '/')
					do writer.writeStr("return f?null:true;\n")
				else
					do writer.writeStr("return f?\"")
					var reader: file@Reader :: file@makeReader(resFile)
					while(!reader.term())
						var line: []char :: reader.readLine()
						for i(0, ^line - 1)
							do writer.writeStr(@escapeChar(line[i]))
						end for
						do writer.writeStr("\\n")
					end while
					do reader.fin()
					do writer.writeStr("\":true;\n")
				end if
				do resFiles.next()
			end while
			if(^resFiles > 0)
				do writer.writeStr("else return f?null:false;\n")
			else
				do writer.writeStr("return f?null:false;\n")
			end if
		end block
		do writer.writeStr("}\n")
		
		block
			do writer.writeStr("function FF_(){return[")
			var first: bool :: true
			do resFiles.head()
			while(!resFiles.term())
				var resFile: []char :: resFiles.get()
				if(first)
					do first :: false
					do writer.writeStr("\"")
				else
					do writer.writeStr(",\"")
				end if
				for i(^\option@inputDir, ^resFile - 1)
					do writer.writeStr(@escapeChar(resFile[i]))
				end for
				do writer.writeStr("\"")
				do resFiles.next()
			end while
			do writer.writeStr("];}\n")
		end block
		
		block
			do writer.writeStr("function DS_(t){\n")
			do writer.writeStr("let i=1;\n")
			do writer.writeStr("!function T(){\n")
			do writer.writeStr("if(t[i]<\{%ref $ \convert@RuntimeTypeId $ int})\n")
			do writer.writeStr("++i;\n")
			do writer.writeStr("else if(t[i]===\{%dict_ $ \convert@RuntimeTypeId $ int})\n")
			do writer.writeStr("++i,T(),T();\n")
			do writer.writeStr("else if(t[i]===\{%class_ $ \convert@RuntimeTypeId $ int})\n")
			do writer.writeStr("++i;\n")
			do writer.writeStr("else\n")
			do writer.writeStr("++i,T();\n")
			do writer.writeStr("}()\n")
			do writer.writeStr("return t[i];\n")
			do writer.writeStr("}\n")
		end block
		
		block
			do writer.writeStr("function R_(c,n){\n")
			do writer.writeStr("if(c.repeat)return c.repeat(n);\n")
			do writer.writeStr("let r=\"\";\n")
			do writer.writeStr("for(let i=0;i<n;i++)r+=c;\n")
			do writer.writeStr("return r;\n")
			do writer.writeStr("}\n")
		end block
		
		if(^@classTable <> 0)
			do @classTable.head()
			while(!@classTable.term())
				var item: []char :: @classTable.get()
				do writer.writeStr(item)
				do @classTable.next()
			end while
		end if
		
		do writer.writeStr("a();\n")
		if(static)
			do writer.writeStr("}\n")
		else
			do writer.writeStr("})\n")
		end if
	end func
end func

func getId(): []char
	var curId: []char :: @uniqueId
	var newId: []char :: ##@uniqueId
	while loop2(true)
		var idx: int :: ^newId - 1
		while loop(true)
			switch(newId[idx])
			case 'z'
				do newId[idx] :: idx = 0 ?('A', '0')
			case '9'
				do newId[idx] :: 'A'
			case 'Z'
				if(idx = 0)
					do newId :: #[^newId + 1]char
					do newId.fill('a')
				else
					do newId[idx] :: 'a'
					do idx :- 1
					skip loop
				end if
			default
				do newId[idx] :: newId[idx].offset(1)
			end switch
			break loop
		end while
		switch(^newId)
		case 2
			switch(newId)
			case "do", "if", "in"
				skip loop2
			end switch
		case 3
			switch(newId)
			case "for", "let", "new", "try", "var", "Map", "NaN", "Set"
				skip loop2
			end switch
		case 4
			switch(newId)
			case "case", "else", "enum", "eval", "name", "null", "this", "true", "void", "with", "Date", "Intl", "JSON", "Math"
				skip loop2
			end switch
		end switch
		break loop2
	end while
	do @uniqueId :: newId
	ret curId
end func

+func getInfo(ast: \ast@Ast): @WebInfo
	if(ast.extra =& null | ast.extra.typeId <> %info)
		var info: @WebInfo :: #@WebInfo
		do info.typeId :: %info
		do info.id :: @getId()
		if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> "$")
			do info.breakSkipLabel :: @getId()
		else
			do info.breakSkipLabel :: null
		end if
		do info.classTableOffset :: -1
		do info.alreadyWritten :: false
		do ast.extra :: info
	end if
	ret ast.extra $ @WebInfo
end func

func addTmpVar(): []char
	var tmpVar: @TmpVar :: #@TmpVar
	do tmpVar.identifier :: @getId()
	do @tmpVars.add(tmpVar)
	ret tmpVar.identifier
end func

func refClass(ast: \ast@AstClass): []char
	var info: @WebInfo :: @getInfo(ast)
	if(info.alreadyWritten)
		ret info.id
	end if
	do info.alreadyWritten :: true
	if(ast.refItem <>& null)
		do @refClass(ast.refItem $ \ast@AstClass)
	end if
	block
		var parentOffset: int
		if(ast.refItem =& null)
			do parentOffset :: 0
		else
			var parentInfo: @WebInfo :: @getInfo(ast.refItem)
			assert parentInfo.classTableOffset <> -1
			do parentOffset :: parentInfo.classTableOffset
		end if
		if(info.classTableOffset = -1)
			do info.classTableOffset :: ^@classTable
		end if
		do @classTable.add("CT_[\{info.classTableOffset}] = \{parentOffset};\n")
		var funcs: dict<int, \ast@AstFunc> :: #dict<int, \ast@AstFunc>
		do setFuncOffsetRecursion(&, funcs, ast, false)
		do funcs.forEach(addFuncPosCallback, null)
	end block
	do @classes.add(ast)
	ret info.id
	
	func setFuncOffsetRecursion(idx: &int, funcs: dict<int, \ast@AstFunc>, ast: \ast@AstClass, parent: bool)
		if(ast.refItem <>& null)
			do setFuncOffsetRecursion(&idx, funcs, ast.refItem $ \ast@AstClass, true)
		end if
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %func_)
				var func_: \ast@AstFunc :: item.def $ \ast@AstFunc
				var info: @WebInfo :: @getInfo(func_)
				if(item.override)
					var parentItem: \ast@AstClassItem :: item.parentItem
					assert parentItem <>& null
					var parentInfo: @WebInfo :: @getInfo(parentItem.def)
					assert parentInfo.classTableOffset <> -1
					do info.classTableOffset :: parentInfo.classTableOffset
				else
					do idx :+ 1
					if(info.classTableOffset = -1)
						do info.classTableOffset :: idx
					else
						assert info.classTableOffset = idx
					end if
				end if
				do funcs.add(info.classTableOffset, func_)
			end if
			do items.next()
		end while
	end func
	
	func addFuncPosCallback(key: int, value: \ast@AstFunc, data: kuin@Class): bool
		var info: @WebInfo :: @getInfo(value)
		var s: []char :: "CT_[\{^@classTable}] = \{info.id};\n"
		do @classTable.add(s)
		ret true
	end func
end func

func getDefaultValue(type: \ast@AstType): []char
	if(\ast@isNullable(type))
		ret "null"
	end if
	switch(type.typeId)
	case %typeUser
		assert \ast@isEnum(type)
		ret "0"
	case %typeBit
		ret "0"
	case %typePrim
		switch((type $ \ast@AstTypePrim).kind)
		case %int_, %char_
			ret "0"
		case %float_
			ret "0"
		case %bool_
			ret "false"
		default
			assert false
		end switch
	default
		assert false
	end switch
end func

func makeTypeId(type: \ast@AstType): []char
	var result: []char :: "["
	var first: bool :: true
	var items: list<int> :: \convert@getTypeId(type)
	do items.head()
	while(!items.term())
		if(first)
			do first :: false
		else
			do result :~ ","
		end if
		do result :~ items.get().toStr()
		do items.next()
	end while
	do result :~ "]"
	ret result
end func

func escapeChar(c: char): []char
	switch(c)
	case '"'
		ret "\\\""
	case '\''
		ret "\\'"
	case '\\'
		ret "\\\\"
	case ' ' to '~'
		ret c.toStr()
	default
		ret "\\u\{(c $ bit16).toStr().sub(2, -1)}"
	end switch
end func
