const classTableItemSize: int :: 2

var funcs: queue<\ast@AstFunc>
var classes: queue<\ast@AstClass>

var uniqueId: []char
var classDefs: list<[]char>
var funcPrototypes: list<[]char>
var codes: list<[]char>
var classFuncs: list<[]char>
var tmpVars: list<@TmpVar>
var globalVars: list<\ast@AstArg>
var localVars: list<\ast@AstArg>
var classTableSize: int
var classTable: list<[]char>

+class CppInfo(\ast@HasType)
	+var id: []char
	+var breakLabel: []char
	+var skipLabel: []char
	+var classTableOffset: int
	+var alreadyWritten: bool
	+var breakLabelUsed: bool
	+var skipLabelUsed: bool
end class

class TmpVar()
	+var identifier: []char
	+var type: \ast@AstType
end class

+func output(entry: \ast@AstFunc): bool
	do @funcs :: #queue<\ast@AstFunc>
	do @funcs.add(entry)
	do @classes :: #queue<\ast@AstClass>
	
	do @uniqueId :: "a"
	do @classDefs :: #list<[]char>
	do @funcPrototypes :: #list<[]char>
	do @codes :: #list<[]char>
	do @classFuncs :: #list<[]char>
	do @tmpVars :: #list<@TmpVar>
	do @globalVars :: #list<\ast@AstArg>
	do @localVars :: #list<\ast@AstArg>
	do @classTableSize :: 0
	do @classTable :: #list<[]char>
	
	while(^@funcs > 0 | ^@classes > 0)
		while(^@funcs > 0)
			var func_: \ast@AstFunc :: @funcs.get()
			do @buildFunc(func_)
		end while
		while(^@classes > 0)
			var class_: \ast@AstClass :: @classes.get()
			do @buildClass(class_)
		end while
	end while
	
	do @write()
	ret true
end func

func buildFunc(ast: \ast@AstFunc)
	var info: @CppInfo :: @getInfo(ast)
	if(info.alreadyWritten)
		ret
	end if
	do info.alreadyWritten :: true
	
	var template: []char :: ""
	if(ast.funcOption.and(%any) = %any)
		if(ast.funcOption.and(%tkv) = %tkv)
			do template :: "template<typename T_, typename K_, typename V_> "
		elif(ast.funcOption.and(%tch) = %tch)
			if(ast.funcOption.and(%rch) = %rch)
				do template :: "template<typename T_, typename C_, typename R_> "
			else
				do template :: "template<typename T_, typename C_> "
			end if
		elif(ast.funcOption.and(%rch) = %rch)
			do template :: "template<typename T_, typename R_> "
		elif(ast.funcOption.and(%kvf) = %kvf)
			do template :: "template<typename T_, typename K_, typename V_> "
		else
			do template :: "template<typename T_> "
		end if
	end if
	
	var retType: []char
	if(ast.funcOption.and(%rch) = %rch)
		do retType :: "R_"
	elif(ast.funcOption.and(%rme) = %rme)
		do retType :: "T_"
	else
		do retType :: @getType(ast.ret_)
	end if
	
	var arg: []char :: ""
	block
		var idx: int :: 0
		var items: list<\ast@AstArg> :: ast.args
		do items.head()
		while(!items.term())
			var item: \ast@AstArg :: items.get()
			if(idx <> 0)
				do arg :~ ", "
			end if
			var info2: @CppInfo :: @getInfo(item)
			if(ast.funcOption.and(%any) = %any & idx = 0)
				assert \ast@isInt(item.type)
				do arg :~ "T_"
			elif(ast.funcOption.and(%tkv) = %tkv & idx = 2)
				assert \ast@isInt(item.type)
				do arg :~ "K_"
			elif(ast.funcOption.and(%tkv) = %tkv & idx = 3)
				assert \ast@isInt(item.type)
				do arg :~ "V_"
			elif(ast.funcOption.and(%tch) = %tch & idx = 2)
				assert \ast@isInt(item.type)
				do arg :~ "C_"
			elif(ast.funcOption.and(%tme) = %tme & idx = 2)
				assert \ast@isInt(item.type)
				do arg :~ "T_"
			elif(ast.funcOption.and(%kvf) = %kvf & idx = 2)
				assert \ast@isInt(item.type)
				do arg :~ "const void*"
			else
				do arg :~ "\{@getType(item.type)}"
			end if
			if(item.refVar)
				do arg :~ "*"
			end if
			do arg :~ " \{info2.id}"
			if(item.name <>& null)
				do arg :~ " /*\{item.name}*/"
			end if
			do items.next()
			do idx :+ 1
		end while
	end block
	
	if(ast.name <>& null)
		do @codes.add("// \{ast.name}\n")
	end if
	do @funcPrototypes.add("\{template}static \{retType} \{info.id}(\{arg});\n")
	do @codes.add("\{template}static \{retType} \{info.id}(\{arg}){\n")
	
	if(ast.funcOption.and(%raw) = %raw)
		if(^ast.funcAttr = 1)
			do ast.funcAttr.head()
			var hasMembers: bool :: false
			if(^ast.args > 0)
				do ast.args.head()
				var arg2: \ast@AstArg :: ast.args.get()
				if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)
					var members: list<\ast@AstClassItem> :: (arg2.type.refItem $ \ast@AstClass).items
					do \cpp\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)
					do hasMembers :: true
				end if
			end if
			if(!hasMembers)
				do \cpp\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)
			end if
			do @codes.add("}\n")
		end if
	else
		do @codes.tail()
		var localVarPos: int :: @codes.idx()
		
		do @buildStats(ast.stats, null, null)
		
		do @codes.add("}\n")
		
		do @codes.head()
		do @codes.moveOffset(localVarPos)
		do @codes.next()
		do @localVars.head()
		while(!@localVars.term())
			var localVar: \ast@AstArg :: @localVars.get()
			var info2: @CppInfo :: @getInfo(localVar)
			if(localVar.name =& null)
				do @codes.ins("\{@getType(localVar.type)} \{info2.id} = \{@getDefaultValue(localVar.type)};\n")
			else
				do @codes.ins("\{@getType(localVar.type)} \{info2.id} = \{@getDefaultValue(localVar.type)}; // \{localVar.name}\n")
			end if
			do @localVars.del()
		end while
		do @tmpVars.head()
		while(!@tmpVars.term())
			var tmpVar: @TmpVar :: @tmpVars.get()
			do @codes.ins("\{@getType(tmpVar.type)} \{tmpVar.identifier} = \{@getDefaultValue(tmpVar.type)};\n")
			do @tmpVars.del()
		end while
	end if
end func

func buildClass(ast: \ast@AstClass)
	var parentId: []char :: null
	if(ast.refItem <>& null)
		do parentId :: @refClass(ast.refItem $ \ast@AstClass)
	end if
	if(parentId =& null)
		do parentId :: "Class_"
	end if
	var info: @CppInfo :: @getInfo(ast)
	block
		assert info.classTableOffset <> -1
		var parentOffset: int
		if(ast.refItem =& null)
			do parentOffset :: 0
		else
			var parentInfo: @CppInfo :: @getInfo(ast.refItem)
			assert parentInfo.classTableOffset <> -1
			do parentOffset :: parentInfo.classTableOffset
		end if
		do @classTable.add("classTable_[\{info.classTableOffset * @classTableItemSize}] = \{parentOffset * @classTableItemSize};\n")
	end block
	if(ast.name <>& null)
		do @classDefs.add("// \{ast.name}\n")
	end if
	do @classDefs.add("class \{info.id} : public \{parentId}{\npublic:\n")
	do @classDefs.add("\{info.id}();\n")
	do @classFuncs.add("\{info.id}::\{info.id}(): \{parentId}()")
	block
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %var_)
				var var_: \ast@AstVar :: item.def $ \ast@AstVar
				var info2: @CppInfo :: @getInfo(var_.arg)
				do @classFuncs.add(", \{info2.id}()")
			end if
			do items.next()
		end while
	end block
	do @classFuncs.add("{\n")
	do @classFuncs.add("Y = \{info.classTableOffset * @classTableItemSize};\n")
	block
		var ctor: \ast@AstFunc :: findFunc(ast, "ctor")
		if(ctor <>& null)
			var ctorInfo: @CppInfo :: @getInfo(ctor)
			do @classFuncs.add("\{ctorInfo.id}(this);\n")
		end if
	end block
	do @classFuncs.add("}\n")
	; TODO: Destructor.
	block
		var cmp: \ast@AstFunc :: findFunc(ast, "cmp")
		if(cmp <>& null)
			var cmpInfo: @CppInfo :: @getInfo(cmp)
			do @classDefs.add("virtual int64_t cmp_(Class_* t) override;\n")
			do @classFuncs.add("int64_t \{info.id}::cmp_(Class_* t){\n")
			do @classFuncs.add("\{info.id}* u = reinterpret_cast<\{info.id}*>(t);\n")
			do @classFuncs.add("return \{cmpInfo.id}(this, u);\n")
			do @classFuncs.add("}\n")
		end if
		var copy: \ast@AstFunc :: findFunc(ast, "_copy")
		block
			assert copy <>& null
			var copyInfo: @CppInfo :: @getInfo(copy)
			do @classDefs.add("virtual Class_* copy_(Class_* t) override;\n")
			do @classFuncs.add("Class_* \{info.id}::copy_(Class_* t){\n")
			do @classFuncs.add("return \{copyInfo.id}(this);\n")
			do @classFuncs.add("}\n")
		end block
	end block
	block
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %var_)
				var var_: \ast@AstVar :: item.def $ \ast@AstVar
				var info2: @CppInfo :: @getInfo(var_.arg)
				if(var_.arg.name =& null)
					do @classDefs.add("\{@getType(var_.arg.type)} \{info2.id};\n")
				else
					do @classDefs.add("\{@getType(var_.arg.type)} \{info2.id}; // \{var_.arg.name}\n")
				end if
			end if
			do items.next()
		end while
	end block
	do @classDefs.add("};\n")
	
	func findFunc(ast: \ast@AstClass, name: []char): \ast@AstFunc
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %func_ & item.def.name = name)
				ret item.def $ \ast@AstFunc
			end if
			do items.next()
		end while
		ret null
	end func
end func

func buildStats(stats: list<\ast@AstStat>, breakStat: \ast@AstStat, skipStat: \ast@AstStat)
	do stats.head()
	while(!stats.term())
		var stat: \ast@AstStat :: stats.get()
		switch(stat.typeId)
		case %statIf
			do @buildIf(stat $ \ast@AstStatIf, breakStat, skipStat)
		case %statSwitch
			do @buildSwitch(stat $ \ast@AstStatSwitch, breakStat, skipStat)
		case %statWhile
			do @buildWhile(stat $ \ast@AstStatWhile, breakStat, skipStat)
		case %statFor
			do @buildFor(stat $ \ast@AstStatFor, breakStat, skipStat)
		case %statTry
			do @buildTry(stat $ \ast@AstStatTry, breakStat, skipStat)
		case %statThrow
			do @buildThrow(stat $ \ast@AstStatThrow)
		case %statBlock
			do @buildBlock(stat $ \ast@AstStatBlock, breakStat, skipStat)
		case %statRet
			do @buildRet(stat $ \ast@AstStatRet)
		case %statDo
			do @buildDo(stat $ \ast@AstStatDo)
		case %statBreak
			do @buildBreak(stat $ \ast@AstStat, breakStat)
		case %statSkip
			do @buildSkip(stat $ \ast@AstStat, skipStat)
		case %statAssert
			do @buildAssert(stat $ \ast@AstStatAssert)
		default
			assert false
		end switch
		do stats.next()
	end while
end func

func buildIf(ast: \ast@AstStatIf, breakStat: \ast@AstStat, skipStat: \ast@AstStat)
	var infoMe: @CppInfo :: @getInfo(ast)
	if(ast.cond =& null)
		; Optimized code.
		do @buildBlock(ast.statBlock, breakStat, skipStat)
		if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
			do @codes.add("\{infoMe.breakLabel}:;\n")
		end if
		ret
	end if
	
	do @codes.add("if(")
	do @buildExpr(ast.cond)
	do @codes.add("){\n")
	do @buildBlock(ast.statBlock, breakStat, skipStat)
	do @codes.add("}\n")
	block
		var items: list<\ast@AstStatElIf> :: ast.elIfs
		do items.head()
		while(!items.term())
			var item: \ast@AstStatElIf :: items.get()
			do @codes.add("else if(")
			do @buildExpr(item.cond)
			do @codes.add("){\n")
			do @buildBlock(item.statBlock, breakStat, skipStat)
			do @codes.add("}\n")
			do items.next()
		end while
	end block
	if(ast.elseStatBlock <>& null)
		do @codes.add("else{\n")
		do @buildBlock(ast.elseStatBlock, breakStat, skipStat)
		do @codes.add("}\n")
	end if
	if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
		do @codes.add("\{infoMe.breakLabel}:;\n")
	end if
end func

func buildSwitch(ast: \ast@AstStatSwitch, breakStat: \ast@AstStat, skipStat: \ast@AstStat)
	var infoMe: @CppInfo :: @getInfo(ast)
	var info: @CppInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	var useSwitch: bool :: false
	if chk(\ast@isInt(ast.cond.type) | \ast@isChar(ast.cond.type) | \ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)
		do useSwitch :: true
		var items: list<\ast@AstStatCase> :: ast.cases
		do items.head()
		while(!items.term())
			var item: \ast@AstStatCase :: items.get()
			var items2: list<\ast@ExprPair> :: item.conds
			do items2.head()
			while(!items2.term())
				var exprs: \ast@ExprPair :: items2.get()
				if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)
					do useSwitch :: false
					break chk
				end if
				do items2.next()
			end while
			do items.next()
		end while
	end if
	if(useSwitch)
		do @codes.add("switch(")
		do @buildExpr(ast.cond)
		do @codes.add("){\n")
		block
			var items: list<\ast@AstStatCase> :: ast.cases
			do items.head()
			while(!items.term())
				var item: \ast@AstStatCase :: items.get()
				var items2: list<\ast@ExprPair> :: item.conds
				do items2.head()
				while(!items2.term())
					var exprs: \ast@ExprPair :: items2.get()
					assert exprs.expr1 =& null
					do @codes.add("case ")
					do @buildExpr(exprs.expr0)
					do @codes.add(":\n")
					do items2.next()
				end while
				do @buildBlock(item.statBlock, ast, skipStat)
				do @codes.add("break;\n")
				do items.next()
			end while
		end block
		if(ast.defaultStatBlock <>& null)
			do @codes.add("default:\n")
			do @buildBlock(ast.defaultStatBlock, ast, skipStat)
			do @codes.add("break;\n")
		end if
		do @codes.add("}\n")
	else
		do @codes.add("\{info.id} = ")
		do @buildExpr(ast.cond)
		do @codes.add(";\n")
		block
			var first: bool :: true
			var items: list<\ast@AstStatCase> :: ast.cases
			do items.head()
			while(!items.term())
				var item: \ast@AstStatCase :: items.get()
				if(first)
					do first :: false
					do @codes.add("if(")
				else
					do @codes.add("else if(")
				end if
				var first2: bool :: true
				var items2: list<\ast@ExprPair> :: item.conds
				do items2.head()
				while(!items2.term())
					var exprs: \ast@ExprPair :: items2.get()
					if(first2)
						do first2 :: false
					else
						do @codes.add(" || ")
					end if
					if(exprs.expr1 =& null)
						if(\ast@isRef(ast.cond.type))
							do @codes.add("cmp_(\{info.id}, (")
							do @buildExpr(exprs.expr0)
							do @codes.add(")) == 0")
						else
							do @codes.add("\{info.id} == (")
							do @buildExpr(exprs.expr0)
							do @codes.add(")")
						end if
					else
						do @codes.add("(")
						do @buildExpr(exprs.expr0)
						do @codes.add(") <= \{info.id} && \{info.id} <= (")
						do @buildExpr(exprs.expr1)
						do @codes.add(")")
					end if
					do items2.next()
				end while
				do @codes.add("){\n")
				do @buildBlock(item.statBlock, breakStat, skipStat)
				do @codes.add("}\n")
				do items.next()
			end while
		end block
		if(ast.defaultStatBlock <>& null)
			do @codes.add("else{")
			do @buildBlock(ast.defaultStatBlock, breakStat, skipStat)
			do @codes.add("}\n")
		end if
	end if
	
	if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
		do @codes.add("\{infoMe.breakLabel}:;\n")
	end if
end func

func buildWhile(ast: \ast@AstStatWhile, breakStat: \ast@AstStat, skipStat: \ast@AstStat)
	var infoMe: @CppInfo :: @getInfo(ast)
	if(ast.cond =& null)
		do @codes.add("for(;;){\n")
		do @buildStats(ast.stats, ast, ast)
		if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)
			do @codes.add("\{infoMe.skipLabel}:;\n")
		end if
		do @codes.add("}\n")
		if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
			do @codes.add("\{infoMe.breakLabel}:;\n")
		end if
		ret
	end if
	if(ast.skip_)
		do @codes.add("do{\n")
		do @buildStats(ast.stats, ast, ast)
		if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)
			do @codes.add("\{infoMe.skipLabel}:;\n")
		end if
		do @codes.add("}while(")
		do @buildExpr(ast.cond)
		do @codes.add(");\n")
		if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
			do @codes.add("\{infoMe.breakLabel}:;\n")
		end if
		ret
	end if
	do @codes.add("while(")
	do @buildExpr(ast.cond)
	do @codes.add("){\n")
	do @buildStats(ast.stats, ast, ast)
	if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)
		do @codes.add("\{infoMe.skipLabel}:;\n")
	end if
	do @codes.add("}\n")
	if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
		do @codes.add("\{infoMe.breakLabel}:;\n")
	end if
end func

func buildFor(ast: \ast@AstStatFor, breakStat: \ast@AstStat, skipStat: \ast@AstStat)
	var infoMe: @CppInfo :: @getInfo(ast)
	var info: @CppInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	var endId: []char :: @addTmpVar(ast.cond.type)
	do @codes.add("for(\{info.id} = (")
	do @buildExpr(ast.start)
	do @codes.add("), \{endId} = (")
	do @buildExpr(ast.cond)
	do @codes.add("); \{info.id} ")
	assert ast.step.typeId = %exprValuePrim & \ast@isInt(ast.cond.type)
	var step: int :: (ast.step $ \ast@AstExprValuePrim).value $ int
	if(step > 0)
		do @codes.add("<=")
	else
		do @codes.add(">=")
	end if
	do @codes.add(" \{endId}; \{info.id} ")
	if(step > 0)
		do @codes.add("+= (")
	else
		do @codes.add("-= (")
	end if
	do @buildExpr(ast.step)
	do @codes.add(")){\n")
	do @buildStats(ast.stats, ast, ast)
	if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)
		do @codes.add("\{infoMe.skipLabel}:;\n")
	end if
	do @codes.add("}\n")
	if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
		do @codes.add("\{infoMe.breakLabel}:;\n")
	end if
end func

func buildTry(ast: \ast@AstStatTry, breakStat: \ast@AstStat, skipStat: \ast@AstStat)
	var infoMe: @CppInfo :: @getInfo(ast)
	var info: @CppInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	if(ast.finallyStatBlock <>& null)
		do @codes.add("try{\n")
	end if
	do @codes.add("try{\n")
	do @buildBlock(ast.statBlock, breakStat, skipStat)
	if(ast.finallyStatBlock <>& null)
		do @buildBlock(ast.finallyStatBlock, breakStat, skipStat)
	end if
	do @codes.add("}catch(int64_t \{info.id}){\n")
	block
		var first: bool :: true
		var items: list<\ast@AstStatCatch> :: ast.catches
		do items.head()
		while(!items.term())
			var item: \ast@AstStatCatch :: items.get()
			if(first)
				do first :: false
				do @codes.add("if(")
			else
				do @codes.add("else if(")
			end if
			var first2: bool :: true
			var items2: list<\ast@ExprPair> :: item.conds
			do items2.head()
			while(!items2.term())
				var exprs: \ast@ExprPair :: items2.get()
				if(first2)
					do first2 :: false
				else
					do @codes.add(" || ")
				end if
				if(exprs.expr1 =& null)
					do @codes.add("\{info.id} == (")
					do @buildExpr(exprs.expr0)
					do @codes.add(")")
				else
					do @codes.add("(")
					do @buildExpr(exprs.expr0)
					do @codes.add(") <= \{info.id} && \{info.id} <= (")
					do @buildExpr(exprs.expr1)
					do @codes.add(")")
				end if
				do items2.next()
			end while
			do @codes.add("){\n")
			do @buildBlock(item.statBlock, breakStat, skipStat)
			do @codes.add("}\n")
			do items.next()
		end while
		if(first)
			do @codes.add("{\n")
		else
			do @codes.add("else{\n")
		end if
		do @codes.add("throw;\n}\n")
	end block
	do @codes.add("}\n")
	if(ast.finallyStatBlock <>& null)
		do @codes.add("}\ncatch(...){\n")
		do @buildBlock(ast.finallyStatBlock, breakStat, skipStat)
		do @codes.add("throw;\n}\n")
	end if
	if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
		do @codes.add("\{infoMe.breakLabel}:;\n")
	end if
end func

func buildThrow(ast: \ast@AstStatThrow)
	do @codes.add("throw ")
	do @buildExpr(ast.code)
	do @codes.add(";\n")
end func

func buildBlock(ast: \ast@AstStatBlock, breakStat: \ast@AstStat, skipStat: \ast@AstStat)
	var infoMe: @CppInfo :: @getInfo(ast)
	do @buildStats(ast.stats, breakStat, skipStat)
	if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)
		do @codes.add("\{infoMe.breakLabel}:;\n")
	end if
end func

func buildRet(ast: \ast@AstStatRet)
	if(ast.value =& null)
		do @codes.add("return;\n")
	else
		do @codes.add("return ")
		do @buildExpr(ast.value)
		do @codes.add(";\n")
	end if
end func

func buildDo(ast: \ast@AstStatDo)
	do @buildExpr(ast.expr)
	do @codes.add(";\n")
end func

func buildBreak(ast: \ast@AstStat, breakStat: \ast@AstStat)
	assert ast.refItem.typeId.and(%statBreakable) = %statBreakable
	if(ast.refItem =& breakStat)
		do @codes.add("break;\n")
	else
		var info: @CppInfo :: @getInfo(ast.refItem)
		do info.breakLabelUsed :: true
		do @codes.add("goto \{info.breakLabel};\n")
	end if
end func

func buildSkip(ast: \ast@AstStat, skipStat: \ast@AstStat)
	assert ast.refItem.typeId.and(%statSkipable) = %statSkipable
	if(ast.refItem =& skipStat)
		do @codes.add("continue;\n")
	else
		var info: @CppInfo :: @getInfo(ast.refItem)
		do info.skipLabelUsed :: true
		do @codes.add("goto \{info.skipLabel};\n")
	end if
end func

func buildAssert(ast: \ast@AstStatAssert)
	do @codes.add("if(!(")
	do @buildExpr(ast.cond)
	do @codes.add(")){\nthrow \{excpt@dbgAssertFailed $ bit32}U;\n}\n")
end func

func buildExpr(ast: \ast@AstExpr)
	switch(ast.typeId)
	case %expr1
		do @buildExpr1(ast $ \ast@AstExpr1)
	case %expr2
		do @buildExpr2(ast $ \ast@AstExpr2)
	case %expr3
		do @buildExpr3(ast $ \ast@AstExpr3)
	case %exprNew
		do @buildExprNew(ast $ \ast@AstExprNew)
	case %exprNewArray
		do @buildExprNewArray(ast $ \ast@AstExprNewArray)
	case %exprAs
		do @buildExprAs(ast $ \ast@AstExprAs)
	case %exprToBin
		do @buildExprToBin(ast $ \ast@AstExprToBin)
	case %exprFromBin
		do @buildExprFromBin(ast $ \ast@AstExprFromBin)
	case %exprCall
		do @buildExprCall(ast $ \ast@AstExprCall)
	case %exprArray
		do @buildExprArray(ast $ \ast@AstExprArray)
	case %exprDot
		do @buildExprDot(ast $ \ast@AstExprDot)
	case %exprValue
		do @buildExprValue(ast $ \ast@AstExprValue)
	case %exprValuePrim
		do @buildExprValuePrim(ast $ \ast@AstExprValuePrim)
	case %exprValueStr
		do @buildExprValueStr(ast $ \ast@AstExprValueStr)
	case %exprValueFloat
		do @buildExprValueFloat(ast $ \ast@AstExprValueFloat)
	case %exprValueArray
		do @buildExprValueArray(ast $ \ast@AstExprValueArray)
	case %exprRef
		do @buildExprRef(ast $ \ast@AstExpr)
	default
		assert false
	end switch
end func

func buildExpr1(ast: \ast@AstExpr1)
	assert ast.varKind <> %unknown
	switch(ast.kind)
	case %plus
		do @buildExpr(ast.child)
	case %minus
		do @codes.add("-(")
		do @buildExpr(ast.child)
		do @codes.add(")")
	case %not
		do @codes.add("!(")
		do @buildExpr(ast.child)
		do @codes.add(")")
	case %copy
		do @codes.add("copy_(")
		do @buildExpr(ast.child)
		do @codes.add(")")
	case %len
		do @codes.add("(")
		do @buildExpr(ast.child)
		do @codes.add(")->Len()")
	default
		assert false
	end switch
end func

func buildExpr2(ast: \ast@AstExpr2)
	assert ast.varKind <> %unknown
	var type: \ast@AstType :: ast.children0.type
	switch(ast.kind)
	case %assign
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(") = (")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %or
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(") || (")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %and
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(") && (")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %lt
		if(\ast@isRef(type))
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add(")) < 0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(") < (")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %gt
		if(\ast@isRef(type))
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add(")) > 0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(") > (")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %le
		if(\ast@isRef(type))
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add(")) <= 0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(") <= (")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %ge
		if(\ast@isRef(type))
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add(")) >= 0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(") >= (")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %eq
		if(\ast@isRef(type))
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add(")) == 0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(") == (")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %nEq
		if(\ast@isRef(type))
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add(")) != 0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(") != (")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %eqRef
		do @codes.add("eqAddr_((")
		do @buildExpr(ast.children0)
		do @codes.add("), (")
		do @buildExpr(ast.children1)
		do @codes.add("))")
	case %nEqRef
		do @codes.add("!eqAddr_((")
		do @buildExpr(ast.children0)
		do @codes.add("), (")
		do @buildExpr(ast.children1)
		do @codes.add("))")
	case %cat
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")->Cat(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %add
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(") + (")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %sub
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(") - (")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %mul
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(") * (")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %div
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(") / (")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %mod
		if(\ast@isInt(type) | type.typeId.and(%typeBit) = %typeBit)
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(") % (")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		else
			assert \ast@isFloat(type)
			do @codes.add("fmod((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add("))")
		end if
	case %pow
		if(\ast@isInt(type) | type.typeId.and(%typeBit) = %typeBit)
			do @codes.add("PowI_((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add("))")
		else
			assert \ast@isFloat(type)
			do @codes.add("pow((")
			do @buildExpr(ast.children0)
			do @codes.add("), (")
			do @buildExpr(ast.children1)
			do @codes.add("))")
		end if
	case %swap
		var tmpVar: []char :: @addTmpVar(type)
		do @codes.add("\{tmpVar} = (")
		do @buildExpr(ast.children0)
		do @codes.add("), (")
		do @buildExpr(ast.children0)
		do @codes.add(") = (")
		do @buildExpr(ast.children1)
		do @codes.add("), (")
		do @buildExpr(ast.children1)
		do @codes.add(") = (\{tmpVar})")
	default
		assert false
	end switch
end func

func buildExpr3(ast: \ast@AstExpr3)
	assert ast.varKind <> %unknown
	do @codes.add("(")
	do @buildExpr(ast.children0)
	do @codes.add(") ? (")
	do @buildExpr(ast.children1)
	do @codes.add(") : (")
	do @buildExpr(ast.children2)
	do @codes.add(")")
end func

func buildExprNew(ast: \ast@AstExprNew)
	assert ast.varKind <> %unknown
	if(\ast@isClass(ast.itemType))
		var class_: \ast@AstClass :: ast.itemType.refItem $ \ast@AstClass
		var id: []char :: @refClass(class_)
		do @codes.add("new \{id}()")
	else
		if(ast.itemType.typeId = %typeGen)
			var gen: \ast@AstTypeGen :: ast.itemType $ \ast@AstTypeGen
			switch(gen.kind)
			case %list_
				do @codes.add("new List_<\{@getType(gen.itemType)}>()")
			case %stack_
				do @codes.add("new Stack_<\{@getType(gen.itemType)}>()")
			case %queue_
				do @codes.add("new Queue_<\{@getType(gen.itemType)}>()")
			default
				assert false
			end switch
		else
			assert ast.itemType.typeId = %typeDict
			var dict_: \ast@AstTypeDict :: ast.itemType $ \ast@AstTypeDict
			do @codes.add("new Dict_<\{@getType(dict_.itemTypeKey)}, \{@getType(dict_.itemTypeValue)}>()")
		end if
	end if
end func

func buildExprNewArray(ast: \ast@AstExprNewArray)
	assert ast.varKind <> %unknown
	do @codes.add("newArray_<\{@getType(ast.itemType)}, \{@getType(ast.type)}>(\{^ast.idces}")
	block
		var items: list<\ast@AstExpr> :: ast.idces
		do items.head()
		while(!items.term())
			do @codes.add(", (")
			do @buildExpr(items.get())
			do @codes.add(")")
			do items.next()
		end while
	end block
	do @codes.add(")")
end func

func buildExprAs(ast: \ast@AstExprAs)
	assert ast.varKind <> %unknown
	switch(ast.kind)
	case %as
		var t1: \ast@AstType :: ast.child.type
		var t2: \ast@AstType :: ast.childType
		if(\ast@isClass(t1))
			assert \ast@isClass(t2)
			var id: []char :: @refClass(t2.refItem $ \ast@AstClass)
			var info: @CppInfo :: @getInfo(t2.refItem)
			do @codes.add("as_<\{id}>(classTable_, (")
			do @buildExpr(ast.child)
			do @codes.add("), \{info.classTableOffset * @classTableItemSize})")
		else
			do @codes.add("static_cast<\{@getType(ast.childType)}>(")
			do @buildExpr(ast.child)
			do @codes.add(")")
		end if
	case %is
		do @refClass(ast.childType.refItem $ \ast@AstClass)
		var info: @CppInfo :: @getInfo(ast.childType.refItem)
		do @codes.add("is_(classTable_, (")
		do @buildExpr(ast.child)
		do @codes.add("), \{info.classTableOffset * @classTableItemSize})")
	case %nIs
		do @refClass(ast.childType.refItem $ \ast@AstClass)
		var info: @CppInfo :: @getInfo(ast.childType.refItem)
		do @codes.add("!is_(classTable_, (")
		do @buildExpr(ast.child)
		do @codes.add("), \{info.classTableOffset * @classTableItemSize})")
	default
		assert false
	end switch
end func

func buildExprToBin(ast: \ast@AstExprToBin)
	assert ast.varKind <> %unknown
	do @codes.add("toBin_(")
	do @buildExpr(ast.child)
	do @codes.add(")")
end func

func buildExprFromBin(ast: \ast@AstExprFromBin)
	assert ast.varKind <> %unknown
	do @codes.add("fromBin_<\{@getType(ast.childType)}>((")
	do @buildExpr(ast.child)
	do @codes.add("), (")
	do @buildExpr(ast.offset)
	do @codes.add("))")
end func

func buildExprCall(ast: \ast@AstExprCall)
	assert ast.varKind <> %unknown
	var funcType: \ast@AstTypeFunc :: ast.func_.type $ \ast@AstTypeFunc
	var template: []char :: null
	if(funcType <>& null & funcType.funcOption.and(%any) = %any)
		var items: list<\ast@AstExprCallArg> :: ast.args
		do items.head()
		var meType: \ast@AstType :: items.get().arg.type
		if(funcType.funcOption.and(%tkv) = %tkv)
			do template :: "<\{@getType(meType)}, \{@getType((meType $ \ast@AstTypeDict).itemTypeKey)}, \{@getType((meType $ \ast@AstTypeDict).itemTypeValue)}>"
		elif(funcType.funcOption.and(%tch) = %tch)
			if(funcType.funcOption.and(%rch) = %rch)
				do template :: "<\{@getType(meType)}, "
				if(meType.typeId = %typeGen)
					do template :~ "\{@getType((meType $ \ast@AstTypeGen).itemType)}, "
				else
					assert meType.typeId = %typeDict
					do template :~ "\{@getType((meType $ \ast@AstTypeDict).itemTypeKey)}, "
				end if
				do template :~ "\{@getType(funcType.ret_)}>"
			else
				do template :: "<\{@getType(meType)}, "
				if(meType.typeId = %typeArray)
					do template :~ "\{@getType((meType $ \ast@AstTypeArray).itemType)}>"
				elif(meType.typeId = %typeGen)
					do template :~ "\{@getType((meType $ \ast@AstTypeGen).itemType)}>"
				else
					assert meType.typeId = %typeDict
					do template :~ "\{@getType((meType $ \ast@AstTypeDict).itemTypeKey)}>"
				end if
			end if
		elif(funcType.funcOption.and(%rch) = %rch)
			do template :: "<\{@getType(meType)}, \{@getType(funcType.ret_)}>"
		elif(funcType.funcOption.and(%kvf) = %kvf)
			do template :: "<\{@getType(meType)}, \{@getType((meType $ \ast@AstTypeDict).itemTypeKey)}, \{@getType((meType $ \ast@AstTypeDict).itemTypeValue)}>"
		else
			do template :: "<\{@getType(meType)}>"
		end if
	end if
	if(template =& null)
		do @codes.add("(")
		do @buildExpr(ast.func_)
		do @codes.add(")")
	else
		do @buildExpr(ast.func_)
		do @codes.add(template)
	end if
	do @codes.add("(")
	block
		var first: bool :: true
		var items: list<\ast@AstExprCallArg> :: ast.args
		do items.head()
		while(!items.term())
			var item: \ast@AstExprCallArg :: items.get()
			if(first)
				do first :: false
				do @codes.add("(")
			else
				do @codes.add(", (")
			end if
			if(item.refVar)
				do @codes.add("&")
			end if
			do @buildExpr(item.arg)
			do @codes.add(")")
			do items.next()
		end while
	end block
	do @codes.add(")")
	
	block
		var type: \ast@AstType :: ast.type
		if(type <>& null)
			if(\ast@isClass(type))
				do @refClass(type.refItem $ \ast@AstClass)
			end if
		end if
	end block
end func

func buildExprArray(ast: \ast@AstExprArray)
	assert ast.varKind <> %unknown
	do @codes.add("(")
	do @buildExpr(ast.var_)
	do @codes.add(")->At(")
	do @buildExpr(ast.idx)
	do @codes.add(")")
end func

func buildExprDot(ast: \ast@AstExprDot)
	assert ast.varKind <> %unknown
	if(\ast@isClass(ast.var_.type))
		var classItem: \ast@AstClassItem :: ast.classItem
		assert classItem <>& null
		do @refClass(ast.var_.type.refItem $ \ast@AstClass)
		var info: @CppInfo
		if(classItem.def.typeId = %var_)
			do info :: @getInfo((classItem.def $ \ast@AstVar).arg)
			do @codes.add("(")
			do @buildExpr(ast.var_)
			do @codes.add(")->\{info.id}")
		else
			assert classItem.def.typeId = %func_
			do info :: @getInfo(classItem.def)
			; 'ast.var_' is calculated elsewhere.
			do @codes.add("\{info.id}")
		end if
	else
		assert ast.refItem.typeId = %exprRef
		do @buildExprRef(ast.refItem $ \ast@AstExpr)
	end if
end func

func buildExprValue(ast: \ast@AstExprValue)
	assert ast.type.typeId = %typeNull
	do @codes.add("nullptr")
end func

func buildExprValuePrim(ast: \ast@AstExprValuePrim)
	var type: \ast@AstType :: ast.type
	if(\ast@isInt(type) | \ast@isEnum(type))
		do @codes.add((ast.value $ int).toStr() ~ "LL")
	elif(\ast@isChar(type))
		do @codes.add("u'\\u\{(ast.value $ bit16).toStr().sub(2, -1)}'")
	elif(\ast@isBool(type))
		do @codes.add(ast.value = 0b64 ?("false", "true"))
	elif(type.typeId = %typeBit)
		switch((type $ \ast@AstTypeBit).size)
		case 1
			do @codes.add("static_cast<uint8_t>(\{ast.value $ bit8}U)")
		case 2
			do @codes.add("static_cast<uint16_t>(\{ast.value $ bit16}U)")
		case 4
			do @codes.add("\{ast.value $ bit32}U")
		case 8
			do @codes.add("\{ast.value $ bit64}ULL")
		default
			assert false
		end switch
	else
		assert false
	end if
end func

func buildExprValueStr(ast: \ast@AstExprValueStr)
	var value: []char :: ast.value
	var s: []char :: "new Array_<char16_t>(\{^value}"
	for i(0, ^value - 1)
		do s :~ ", u'\\u\{(value[i] $ bit16).toStr().sub(2, -1)}'"
	end for
	do s :~ ")"
	do @codes.add(s)
end func

func buildExprValueFloat(ast: \ast@AstExprValueFloat)
	var value: []char :: ast.value.toStr()
	if(value = "inf")
		do @codes.add("std::numeric_limits<double>::infinity()")
	elif(value.find('.', -1) = -1)
		do @codes.add(value ~ ".0")
	else
		do @codes.add(value)
	end if
end func

func buildExprValueArray(ast: \ast@AstExprValueArray)
	; Note that constant string values are handled by 'ExprValueStr'.
	do @codes.add("new Array_<\{@getType((ast.type $ \ast@AstTypeArray).itemType)}>(\{^ast.values}")
	var items: list<\ast@AstExpr> :: ast.values
	do items.head()
	while(!items.term())
		do @codes.add(", (")
		do @buildExpr(items.get())
		do @codes.add(")")
		do items.next()
	end while
	do @codes.add(")")
end func

func buildExprRef(ast: \ast@AstExpr)
	var ast2: \ast@Ast :: ast.refItem
	var info: @CppInfo :: @getInfo(ast2)
	if(ast2.typeId = %func_)
		do @funcs.add(ast2 $ \ast@AstFunc)
	else
		assert ast2.typeId = %arg
		var arg: \ast@AstArg :: ast2 $ \ast@AstArg
		switch(arg.kind)
		case %global
			if(!info.alreadyWritten)
				do info.alreadyWritten :: true
				do @globalVars.add(arg)
			end if
		case %localArg
			; Do nothing.
		case %localVar
			if(!info.alreadyWritten)
				do info.alreadyWritten :: true
				do @localVars.add(arg)
			end if
		default
			assert false
		end switch
		if(arg.refVar)
			do @codes.add("*")
		end if
	end if
	do @codes.add(info.id)
end func

func write()
	do file@copyFile(\option@outputDir ~ "common.h", \option@sysDir ~ "common.h")
	
	var writer: file@Writer :: file@makeWriter(\option@outputFile ~ ".cpp", false)
	do writer.writeStr("#include \"common.h\"\n")
	do writer.writeStr("namespace {\n")
	
	do @classDefs.head()
	while(!@classDefs.term())
		do writer.writeStr(@classDefs.get())
		do @classDefs.next()
	end while
	do @funcPrototypes.head()
	while(!@funcPrototypes.term())
		do writer.writeStr(@funcPrototypes.get())
		do @funcPrototypes.next()
	end while
	if(@classTableSize <> 0)
		do writer.writeStr("static int64_t classTable_[\{@classTableSize * @classTableItemSize}];\n")
	end if
	do @globalVars.head()
	while(!@globalVars.term())
		var globalVar: \ast@AstArg :: @globalVars.get()
		var info: @CppInfo :: @getInfo(globalVar)
		do writer.writeStr("static \{@getType(globalVar.type)} \{info.id};\n")
		do @globalVars.next()
	end while
	do @classFuncs.head()
	while(!@classFuncs.term())
		do writer.writeStr(@classFuncs.get())
		do @classFuncs.next()
	end while
	do @codes.head()
	while(!@codes.term())
		do writer.writeStr(@codes.get())
		do @codes.next()
	end while
	do writer.writeStr("}\n")
	do writer.writeStr("int main(){\n")
	block
		do @classTable.head()
		while(!@classTable.term())
			var item: []char :: @classTable.get()
			do writer.writeStr(item)
			do @classTable.next()
		end while
	end block
	do writer.writeStr("init_();\n")
	do writer.writeStr("a();\n")
	do writer.writeStr("return 0;\n")
	do writer.writeStr("}\n")
	do writer.fin()
end func

func getType(type: \ast@AstType): []char
	if(type =& null)
		ret "void"
	end if
	switch(type.typeId)
	case %typeArray
		ret "Array_<\{@getType((type $ \ast@AstTypeArray).itemType)}>*"
	case %typeBit
		ret "uint\{(type $ \ast@AstTypeBit).size * 8}_t"
	case %typeFunc
		var func_: \ast@AstTypeFunc :: type $ \ast@AstTypeFunc
		var id: []char :: @getId()
		do @funcPrototypes.add("typedef \{@getType(func_.ret_)}(*\{id})(")
		block
			var arg: []char :: ""
			var first: bool :: true
			var items: list<\ast@AstTypeFuncArg> :: func_.args
			do items.head()
			while(!items.term())
				var item: \ast@AstTypeFuncArg :: items.get()
				if(first)
					do first :: false
				else
					do arg :~ ", "
				end if
				do arg :~ "\{@getType(item.arg)}"
				if(item.refVar)
					do arg :~ "*"
				end if
				do items.next()
			end while
			do @funcPrototypes.add("\{arg});\n")
		end block
		ret id
	case %typeGen
		var gen: \ast@AstTypeGen :: type $ \ast@AstTypeGen
		switch(gen.kind)
		case %list_
			ret "List_<\{@getType(gen.itemType)}>*"
		case %stack_
			ret "Stack_<\{@getType(gen.itemType)}>*"
		case %queue_
			ret "Queue_<\{@getType(gen.itemType)}>*"
		default
			assert false
		end switch
	case %typeDict
		var dict_: \ast@AstTypeDict :: type $ \ast@AstTypeDict
		ret "Dict_<\{@getType(dict_.itemTypeKey)}, \{@getType(dict_.itemTypeValue)}>*"
	case %typePrim
		var prim: \ast@AstTypePrim :: type $ \ast@AstTypePrim
		switch(prim.kind)
		case %int_
			ret "int64_t"
		case %float_
			ret "double"
		case %char_
			ret "char16_t"
		case %bool_
			ret "bool"
		default
			assert false
		end switch
	case %typeUser
		var ref: \ast@Ast :: type.refItem
		if(ref.typeId = %class_)
			do @refClass(ref $ \ast@AstClass)
			var info: @CppInfo :: @getInfo(ref)
			ret info.id ~ "*"
		else
			assert ref.typeId = %enum_
			ret "int64_t"
		end if
	case %typeNull
		assert false
	default
		assert false
	end switch
end func

func getId(): []char
	var curId: []char :: @uniqueId
	var newId: []char :: ##@uniqueId
	while loop2(true)
		var idx: int :: ^newId - 1
		while loop(true)
			if(newId[idx] = 'z')
				if(idx = 0)
					do newId :: #[^newId + 1]char
					do newId.fill('a')
				else
					do newId[idx] :: 'a'
					do idx :- 1
					skip loop
				end if
			else
				do newId[idx] :: newId[idx].offset(1)
			end if
			break loop
		end while
		switch(^newId)
		case 2
			switch(newId)
			case "do", "if", "or"
				skip loop2
			end switch
		case 3
			switch(newId)
			case "and", "asm", "for", "int", "new", "not", "try", "xor"
				skip loop2
			end switch
		case 4
			switch(newId)
			case "auto", "bool", "case", "char", "else", "enum", "goto", "long", "main", "this", "true", "void"
				skip loop2
			end switch
		end switch
		break loop2
	end while
	do @uniqueId :: newId
	ret curId
end func

+func getInfo(ast: \ast@Ast): @CppInfo
	if(ast.extra =& null | ast.extra.typeId <> %info)
		var info: @CppInfo :: #@CppInfo
		do info.typeId :: %info
		do info.id :: @getId()
		if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> "$")
			do info.breakLabel :: @getId()
			if(ast.typeId.and(%statSkipable) = %statSkipable)
				do info.skipLabel :: @getId()
			else
				do info.skipLabel :: null
			end if
		else
			do info.breakLabel :: null
			do info.skipLabel :: null
		end if
		do info.classTableOffset :: -1
		do info.alreadyWritten :: false
		do info.breakLabelUsed :: false
		do info.skipLabelUsed :: false
		do ast.extra :: info
	end if
	ret ast.extra $ @CppInfo
end func

func addTmpVar(type: \ast@AstType): []char
	var tmpVar: @TmpVar :: #@TmpVar
	do tmpVar.identifier :: @getId()
	do tmpVar.type :: type
	do @tmpVars.add(tmpVar)
	ret tmpVar.identifier
end func

func refClass(ast: \ast@AstClass): []char
	var info: @CppInfo :: @getInfo(ast)
	if(info.alreadyWritten)
		ret info.id
	end if
	do info.alreadyWritten :: true
	if(ast.refItem <>& null)
		do @refClass(ast.refItem $ \ast@AstClass)
	end if
	if(info.classTableOffset = -1)
		do info.classTableOffset :: @classTableSize
		do @classTableSize :+ 1
	end if
	block
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %func_)
				var func_: \ast@AstFunc :: item.def $ \ast@AstFunc
				if(func_.ret_ <>& null)
					do @getType(func_.ret_)
				end if
				var items2: list<\ast@AstArg> :: func_.args
				do items2.head()
				while(!items2.term())
					var arg: \ast@AstArg :: items2.get()
					do @getType(arg.type)
					do items2.next()
				end while
				do @funcs.add(func_)
			elif(item.def.typeId = %var_)
				var var_: \ast@AstVar :: item.def $ \ast@AstVar
				do @getType(var_.arg.type)
			end if
			do items.next()
		end while
	end block
	do @classes.add(ast)
	ret info.id
end func

func getDefaultValue(type: \ast@AstType): []char
	if(\ast@isNullable(type))
		ret "nullptr"
	end if
	switch(type.typeId)
	case %typeUser
		assert \ast@isEnum(type)
		ret "0"
	case %typeBit
		ret "0"
	case %typePrim
		switch((type $ \ast@AstTypePrim).kind)
		case %int_, %char_
			ret "0"
		case %float_
			ret "0.0"
		case %bool_
			ret "false"
		default
			assert false
		end switch
	default
		assert false
	end switch
end func
