+enum RuntimeTypeId
	int_
	float_
	char_
	bool_
	bit8_
	bit16_
	bit32_
	bit64_
	func_
	enum_
	ref :: 0x80
	array
	list_
	stack_
	queue_
	dict_
	class_
end enum

+enum MethodOffset
	ctor :: 1
	dtor
	cmp
	copy
	toBin
	fromBin
	toStr
end enum

+func getTypeId(type: \ast@AstType): list<int>
	var result: list<int> :: #list<int>
	do @makeTypeIdRecursion(type, result)
	ret result
end func

func makeTypeIdRecursion(type: \ast@AstType, output: list<int>)
	if(\ast@isInt(type))
		do output.add(%int_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(\ast@isFloat(type))
		do output.add(%float_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(\ast@isChar(type))
		do output.add(%char_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(\ast@isBool(type))
		do output.add(%bool_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(type.typeId = %typeBit)
		switch((type $ \ast@AstTypeBit).size)
		case 1
			do output.add(%bit8_ $ @RuntimeTypeId $ int)
		case 2
			do output.add(%bit16_ $ @RuntimeTypeId $ int)
		case 4
			do output.add(%bit32_ $ @RuntimeTypeId $ int)
		case 8
			do output.add(%bit64_ $ @RuntimeTypeId $ int)
		default
			assert false
		end switch
		ret
	end if
	if(type.typeId = %typeFunc)
		do output.add(%func_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(\ast@isEnum(type))
		do output.add(%enum_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(type.typeId = %typeArray)
		do output.add(%array $ @RuntimeTypeId $ int)
		do @makeTypeIdRecursion((type $ \ast@AstTypeArray).itemType, output)
		ret
	end if
	if(type.typeId = %typeGen)
		switch((type $ \ast@AstTypeGen).kind)
		case %list_
			do output.add(%list_ $ @RuntimeTypeId $ int)
		case %stack_
			do output.add(%stack_ $ @RuntimeTypeId $ int)
		case %queue_
			do output.add(%queue_ $ @RuntimeTypeId $ int)
		default
			assert false
		end switch
		do @makeTypeIdRecursion((type $ \ast@AstTypeGen).itemType, output)
		ret
	end if
	if(type.typeId = %typeDict)
		do output.add(%dict_ $ @RuntimeTypeId $ int)
		do @makeTypeIdRecursion((type $ \ast@AstTypeDict).itemTypeKey, output)
		do @makeTypeIdRecursion((type $ \ast@AstTypeDict).itemTypeValue, output)
		ret
	end if
	assert \ast@isClass(type)
	do output.add(%class_ $ @RuntimeTypeId $ int)
end func

+func parseExcode(ast: \ast@AstStatExcode, func_: \ast@AstFunc, getIdCodeFunc: func<(\ast@AstArg): []char>): []char
	var ptr: int :: 0
	var code: []char :: (ast.code $ \ast@AstExprValueStr).value
	var s: []char :: ""
	var funcArgs: list<\ast@AstArg> :: func_.args
	var listPtr: kuin@ListPtr :: funcArgs.getPtr()
	var args: []\ast@AstArg :: #[^funcArgs]\ast@AstArg
	do funcArgs.head()
	for i(0, ^args - 1)
		do args[i] :: funcArgs.get()
		do funcArgs.next()
	end for
	do funcArgs.setPtr(listPtr)
	while(ptr < ^code)
		var pos: int :: code.find('`', ptr)
		if(pos = ptr)
			do ptr :+ 1
			var value: []char :: parseValue(code, &ptr)
			if(^value >= 1 & value[0] = '.')
				var class_: \ast@AstClass :: null
				if(func_.funcOption.and(%any) = %none & ^args >= 1 & args[0].type.refItem <>& null & args[0].type.refItem.typeId = %class_)
					do class_ :: (args[0].type.refItem $ \ast@AstClass)
				elif(func_.funcOption.and(%any) <> %none & ^args >= 3 & args[2].type.refItem <>& null & args[2].type.refItem.typeId = %class_)
					do class_ :: (args[2].type.refItem $ \ast@AstClass)
				end if
				if(class_ <>& null)
					var name: []char :: value.sub(1, -1)
					var members: list<\ast@AstClassItem> :: class_.items
					do members.head()
					while loop(!members.term())
						var def: \ast@Ast :: members.get().def
						if(def.typeId = %var_ & (def $ \ast@AstVar).arg.name <>& null & (def $ \ast@AstVar).arg.name = name)
							do s :~ getIdCodeFunc((def $ \ast@AstVar).arg)
							break loop
						end if
						do members.next()
					end while
				end if
			else
				var success: bool
				var value2: int :: value.toInt(&success)
				if(success & value2 < ^args)
					do s :~ getIdCodeFunc(args[value2])
				end if
			end if
		elif(pos = -1)
			do s :~ code.sub(ptr, -1)
			do ptr :: ^code
		else
			do s :~ code.sub(ptr, pos - ptr)
			do ptr :: pos
		end if
	end while
	ret s
	
	func parseValue(code: []char, ptr: &int): []char
		var pos: int :: code.find('`', ptr)
		var value: []char
		if(pos = -1)
			do value :: code.sub(ptr, -1)
			do ptr :: ^code
		else
			do value :: code.sub(ptr, pos - ptr)
			do ptr :: pos + 1
		end if
		ret value
	end func
end func

+func bit16ToBin(n: bit16): []bit8
	ret[n $ bit8, n.shr(8) $ bit8]
end func

+func bit32ToBin(n: bit32): []bit8
	ret[n $ bit8, n.shr(8) $ bit8, n.shr(16) $ bit8, n.shr(24) $ bit8]
end func

+func bit64ToBin(n: bit64): []bit8
	ret[n $ bit8, n.shr(8) $ bit8, n.shr(16) $ bit8, n.shr(24) $ bit8, n.shr(32) $ bit8, n.shr(40) $ bit8, n.shr(48) $ bit8, n.shr(56) $ bit8]
end func

+func getResFiles(): list<[]char>
	class ResFiles()
		+var files: list<[]char>
	end class
	var resFiles: ResFiles :: #ResFiles
	do resFiles.files :: #list<[]char>
	if(file@exist(\option@resDir))
		do file@forEach(\option@resDir, true, searchResFiles, resFiles)
	end if
	ret resFiles.files
	
	func searchResFiles(path: []char, isDir: bool, data: kuin@Class): bool
		var data2: ResFiles :: data $ ResFiles
		do data2.files.add(path)
		ret true
	end func
end func

+func writeResFiles()
	if(\option@rls)
		do archive(getResFiles())
	else
		var src: []char :: \option@resDir
		var dst: []char :: \option@outputDir ~ "res/"
		if(src = dst)
			ret
		end if
		do file@copyDir(dst, src)
	end if
	
	class Path()
		+*func cmp(t: kuin@Class): int
			ret(me.hash - (t $ Path).hash) $ int
		end func
		
		+var path: []char
		+var hash: bit64
	end class
	
	func getResFiles(): []Path
		var resFiles: list<[]char> :: @getResFiles()
		var result: list<Path> :: #list<Path>
		var resDirLen: int :: ^\option@resDir
		do resFiles.head()
		while loop(!resFiles.term())
			var resFile: []char :: resFiles.get()
			if(resFile[^resFile - 1] = '/')
				do resFiles.next()
				skip loop
			end if
			var path: Path :: #Path
			do path.path :: resFile
			block
				var p: []char :: resFile.sub(resDirLen, -1)
				var s: []bit8 :: #[2 * ^p]bit8
				for i(0, ^p - 1)
					do s[i * 2 + 0] :: p[i] $ bit8
					do s[i * 2 + 1] :: (p[i] $ bit16).shr(8) $ bit8
				end for
				do path.hash :: hash@xxh64(s, 917b64)
			end block
			do result.add(path)
			do resFiles.next()
		end while
		var result2: []Path :: result.toArray()
		do result2.sort()
		ret result2
	end func
	
	func archive(paths: []Path)
		var writer: file@Writer :: file@makeWriter(\option@outputDir ~ "res.knd", false)
		var key: bit64 :: lib@rndBit64().xor(0x8364FF023819442Eb64)
		do writer.write(@bit64ToBin(key))
		do key :: key.xor(\option@appCode $ bit64 * 0x9271AC8394027ACBb64 + 0x35718394CA72849Eb64)
		block
			var signature: bit64 :: (0x83261772FA0C01A7b64).xor(key)
			do writer.write(@bit64ToBin(signature))
			var len: bit64 :: ((^paths) $ bit64).xor(0x9C4CAB83CE74A67Eb64).xor(key)
			do writer.write(@bit64ToBin(len))
		end block
		var offset: int :: 0x18 + ^paths * 0x10
		for i(0, ^paths - 1)
			do writer.write(@bit64ToBin(paths[i].hash.xor(0x8121BBA7C238010Fb64).xor(key)))
			do writer.write(@bit64ToBin((offset $ bit64).xor(0x17100B7AC917DC87b64).xor(key)))
			do offset :+ file@fileSize(paths[i].path)
		end for
		for i(0, ^paths - 1)
			var reader: file@Reader :: file@makeReader(paths[i].path)
			var bin: []bit8 :: reader.read(reader.fileSize())
			do reader.fin()
			for j(0, ^bin - 1)
				do bin[j] :: bin[j].xor(((j $ bit64).xor(key) * 0x351CD819923ACAE7b64).shr(32) $ bit8)
			end for
			do writer.write(bin)
		end for
		do writer.fin()
	end func
end func
