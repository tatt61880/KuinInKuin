+const envCui: bit64 :: 0b64
+const envWnd: bit64 :: 1b64

+class Class()
	func ctor()
	end func
	
	func _dtor()
	end func
	
	+func cmp(t: @Class): int
		throw 0xE9170004
	end func
	
	func _copy(): @Class
	end func
	
	func _toBin(): []bit8
	end func
	
	func _fromBin(bin: []bit8, idx: &int): @Class
	end func
	
	+func toStr(): []char
		ret ""
	end func
end class

func _init()
end func

func _fin()
end func

func _err(excpt: int)
	; TODO:
end func

func _initVars()
end func

func _finVars()
end func

+class ListPtr()
	*func[__ndc]ctor()
	end func
	
	var ptr: int
end class

func _absFloat(me_: float): float
	ret me_ >= 0.0 ?(me_, -me_)
end func

func _absInt(me_: int): int
	ret me_ >= 0 ?(me_, -me_)
end func

func[__any, __tkv]_addDict(me_: int, type: []int, key: int, item: int)
	excode "`0`->Add(`2`,`3`);\n"
end func

func[__any, __tch]_addList(me_: int, type: []int, item: int)
	excode "`0`->B.push_back(`2`);\n"
end func

func[__any, __tch]_addQueue(me_: int, type: []int, item: int)
	excode "`0`->B.push(`2`);\n"
end func

func[__any, __tch]_addStack(me_: int, type: []int, item: int)
	excode "`0`->B.push(`2`);\n"
end func

func[__any, __tme, __rme]_and(me_: int, type: []int, n: int): int
	excode "return `0`&`2`;\n"
end func

func[__any]_del(me_: int, type: []int)
	if(dbg)
		excode "if(`0`->I==`0`->B.end())throw 0xe917000a;\n"
	end if
	excode "auto i_=`0`->I++;\n"
	excode "`0`->B.erase(i_);\n"
end func

func[__any, __tch]_delDict(me_: int, type: []int, key: int)
	excode "`0`->Del(`2`);\n"
end func

func[__any]_delNext(me_: int, type: []int)
	if(dbg)
		excode "if(`0`->I==`0`->B.end())throw 0xe917000a;\n"
	end if
	excode "auto n_=`0`->I;\n"
	excode "++n_;\n"
	if(dbg)
		excode "if(n_==`0`->B.end())throw 0xe917000a;\n"
	end if
	excode "`0`->B.erase(n_);\n"
end func

func[__any, __rme]_endian(me_: int, type: []int): int
	excode "return endian_(`0`);\n"
end func

func[__any, __tch, __raw, exist]_exist(me_: int, type: []int, key: int): bool
	excode "auto n_=`0`->B;\n"
	excode "while(n_!=nullptr){\n"
	excode "int64_t c_=cmp_(`2`, n_->K);\n"
	excode "if(c_==0)return true;\n"
	excode "if(c_<0)n_=n_->CL;else n_=n_->CR;\n"
	excode "}\n"
	excode "return false;\n"
end func

func[__any, __tch]_fill(me_: int, type: []int, value: int)
	excode "for(int64_t i_=0;i_<`0`->L;i_++)`0`->B[i_]=`2`;\n"
end func

func[__any, __tch]_findArray(me_: int, type: []int, item: int, start: int): int
	excode "if(`3`==-1)`3`=0;\n"
	excode "if(`3`<0)return -1;\n"
	excode "for(int64_t i_=`3`;i_<`0`->L;i_++){\n"
	excode "if(cmp_(`0`->B[i_],`2`)==0)return i_;\n"
	excode "}\n"
	excode "return -1;\n"
end func

func[__any, __tch]_findBin(me_: int, type: []int, item: int): int
	excode "int64_t a_=0,b_=`0`->L-1;\n"
	excode "while(a_<=b_){\n"
	excode "int64_t c_=(a_+b_)/2;\n"
	excode "int64_t m_=cmp_(`2`,`0`->B[c_]);\n"
	excode "if(m_<0)b_=c_-1;\n"
	excode "else if(m_>0)a_=c_+1;\n"
	excode "else return c_;\n"
	excode "}\n"
	excode "return -1;\n"
end func

func[__any, __tch]_findLastArray(me_: int, type: []int, item: int, start: int): int
	excode "if(`3`==-1)`3`=`0`->L-1;\n"
	excode "if(`3`>=`0`->L)return -1;\n"
	excode "for(int64_t i_=`3`;i_>=0;i_--){\n"
	excode "if(cmp_(`0`->B[i_],`2`)==0)return i_;\n"
	excode "}\n"
	excode "return -1;\n"
end func

func[__any, __tch]_findLastList(me_: int, type: []int, item: int): bool
	excode "for(;;){\n"
	excode "auto c_=`0`->I;\n"
	excode "if(c_==`0`->B.end())return false;\n"
	excode "if(cmp_(*c_,`2`)==0)return true;\n"
	excode "if(`0`->I==`0`->B.begin())`0`->I=`0`->B.end();else --`0`->I;\n"
	excode "}\n"
end func

func[__any, __tch]_findList(me_: int, type: []int, item: int): bool
	excode "for(;;){\n"
	excode "auto c_=`0`->I;\n"
	excode "if(c_==`0`->B.end())return false;\n"
	excode "if(cmp_(*c_,`2`)==0)return true;\n"
	excode "++`0`->I;\n"
	excode "}\n"
end func

func _findStr(me_: []char, pattern: []char, start: int): int
	if(start = -1)
		do start :: 0
	end if
	if(start < 0)
		ret -1
	end if
	for i(start, ^me_ - ^pattern)
		for j(0, ^pattern - 1)
			if(me_[i + j] <> pattern[j])
				skip i
			end if
		end for
		ret i
	end for
	ret - 1
end func

func _findStrLast(me_: []char, pattern: []char, start: int): int
	if(start = -1)
		do start :: ^me_ - ^pattern
	end if
	for i(start < ^me_ - ^pattern ?(start, ^me_ - ^pattern), 0, -1)
		for j(0, ^pattern - 1)
			if(me_[i + j] <> pattern[j])
				skip i
			end if
		end for
		ret i
	end for
	ret - 1
end func

func _findStrEx(me_: []char, pattern: []char, start: int, fromLast: bool, ignoreCase: bool, wholeWord: bool): int
	; TODO:
end func

func[__any, __kvf]_forEach(me_: int, type: []int, callback: int, data: @Class): bool
	excode "return dictForEach_(`0`->B,reinterpret_cast<bool(*)(K_,V_,type_(Class_))>(`2`),`3`);\n"
end func

func[__any, __tch, __rch]_getDict(me_: int, type: []int, key: int, existed: &bool): int
	excode "return dictSearch_(`0`->B,`2`,`3`);\n"
end func

func[__any, __rch]_getList(me_: int, type: []int): int
	if(dbg)
		excode "if(`0`->I==`0`->B.end())throw 0xe917000a;\n"
	end if
	excode "return *`0`->I;\n"
end func

func[__any, __rch]_getOffset(me_: int, type: []int, offset: int): int
	excode "auto p_=`0`->I;\n"
	excode "if(`2`>=0){\n"
	excode "for(int64_t i_=0;i_<`2`;i_++){\n"
	if(dbg)
		excode "if(p_==`0`->B.end())throw 0xe917000a;\n"
	end if
	excode "++p_;\n"
	excode "}\n"
	excode "}else{\n"
	excode "for(int64_t i_=0;i_>`2`;i_--){\n"
	if(dbg)
		excode "if(p_==`0`->B.end())throw 0xe917000a;\n"
	end if
	excode "if(p_==`0`->B.begin())p_=`0`->B.end();else --p_;\n"
	excode "}\n"
	excode "}\n"
	if(dbg)
		excode "if(p_==`0`->B.end())throw 0xe917000a;\n"
	end if
	excode "return *p_;\n"
end func

func[__any, __mki]_getPtr(me_: int, type: []int, me2: @ListPtr): @ListPtr
	excode "auto l_=newPrim_(listPtr_<decltype(`0`->B)>)();\n"
	excode "`2`->`.ptr`=reinterpret_cast<int64_t>(l_);\n"
	excode "l_->I=`0`->I;\n"
	ret me2
end func

func[__any, __rch]_getQueue(me_: int, type: []int): int
	if(dbg)
		excode "if(`0`->B.empty())throw 0xe917000a;\n"
	end if
	excode "R_ r_=`0`->B.front();\n"
	excode "`0`->B.pop();\n"
	excode "return r_;\n"
end func

func[__any, __rch]_getStack(me_: int, type: []int): int
	if(dbg)
		excode "if(`0`->B.empty())throw 0xe917000a;\n"
	end if
	excode "R_ r_=`0`->B.top();\n"
	excode "`0`->B.pop();\n"
	excode "return r_;\n"
end func

func[__any]_head(me_: int, type: []int)
	excode "`0`->I=`0`->B.begin();\n"
end func

func[__any]_idx(me_: int, type: []int): int
	excode "int64_t i_=0;\n"
	excode "if(`0`->I==`0`->B.end())return -1;\n"
	excode "for(auto t_=`0`->B.begin();t_!=`0`->B.end();++t_){\n"
	excode "if(t_==`0`->I)return i_;\n"
	excode "i_++;\n"
	excode "}\n"
	excode "return -1;\n"
end func

func[__any, __tch]_ins(me_: int, type: []int, item: int)
	if(dbg)
		excode "if(`0`->I==`0`->B.end())throw 0xe917000a;\n"
	end if
	excode "`0`->B.insert(`0`->I,`2`);\n"
end func

func _join(me_: [][]char, delimiter: []char): []char
	var t: int :: ^delimiter * (^me_ - 1)
	for i(0, ^me_ - 1)
		do t :+ ^me_[i]
	end for
	var r: []char :: #[t]char
	var p: int :: 0
	for i(0, ^me_ - 1)
		if(i <> 0)
			for j(0, ^delimiter - 1)
				do r[p] :: delimiter[j]
				do p :+ 1
			end for
		end if
		var s: []char :: me_[i]
		for j(0, ^s - 1)
			do r[p] :: s[j]
			do p :+ 1
		end for
	end for
	ret r
end func

func _lower(me_: []char): []char
	var s: []char :: #[^me_]char
	for i(0, ^me_ - 1)
		if('A' <= me_[i] & me_[i] <= 'Z')
			do s[i] :: (me_[i] $ bit64 - 0x41b64 + 0x61b64) $ char
		else
			do s[i] :: me_[i]
		end if
	end for
	ret s
end func

func[__any, __rch, __raw, max]_max(me_: int, type: []int): int
	excode "using TI_=decltype(*`0`->B);\n"
	excode "int64_t l_=`0`->L;\n"
	excode "TI_ r_;\n"
	excode "if(l_==0)return(TI_)0;\n"
	excode "for(int64_t i_=0;i_<l_;i_++){\n"
	excode "if(i_==0||cmp_(r_,`0`->B[i_])<0)r_=`0`->B[i_];\n"
	excode "}\n"
	excode "return r_;\n"
end func

func[__any, __rch, __raw, min]_min(me_: int, type: []int): int
	excode "using TI_=decltype(*`0`->B);\n"
	excode "int64_t l_=`0`->L;\n"
	excode "TI_ r_;\n"
	excode "if(l_==0)return(TI_)0;\n"
	excode "for(int64_t i_=0;i_<l_;i_++){\n"
	excode "if(i_==0||cmp_(r_,`0`->B[i_])>0)r_=`0`->B[i_];\n"
	excode "}\n"
	excode "return r_;\n"
end func

func[__any]_moveOffset(me_: int, type: []int, offset: int)
	excode "if(`2`>=0){\n"
	excode "for(int64_t i_=0;i_<`2`;i_++){\n"
	excode "if(`0`->I==`0`->B.end())break;\n"
	excode "++`0`->I;\n"
	excode "}\n"
	excode "}else{\n"
	excode "for(int64_t i_=0;i_>`2`;i_--){\n"
	excode "if(`0`->I==`0`->B.end())break;\n"
	excode "if(`0`->I==`0`->B.begin())\n"
	excode "`0`->I=`0`->B.end();\n"
	excode "else\n"
	excode "--`0`->I;\n"
	excode "}\n"
	excode "}\n"
end func

func[__any]_next(me_: int, type: []int)
	excode "if(`0`->I==`0`->B.end())return;\n"
	excode "++`0`->I;\n"
end func

func[__any, __rme]_not(me_: int, type: []int): int
	excode "return ~`0`;\n"
end func

func _offset(me_: char, n: int): char
	ret(me_ $ bit64 + n $ bit64) $ char
end func

func[__any, __tme, __rme]_or(me_: int, type: []int, n: int): int
	excode "return `0`|`2`;\n"
end func

func[__any, __rch]_peekQueue(me_: int, type: []int): int
	if(dbg)
		excode "if(`0`->B.empty())throw 0xe917000a;\n"
	end if
	excode "return `0`->B.front();\n"
end func

func[__any, __rch]_peekStack(me_: int, type: []int): int
	if(dbg)
		excode "if(`0`->B.empty())throw 0xe917000a;\n"
	end if
	excode "return `0`->B.top();\n"
end func

func[__any]_prev(me_: int, type: []int)
	excode "if(`0`->I==`0`->B.end())return;\n"
	excode "if(`0`->I==`0`->B.begin())\n"
	excode "`0`->I=`0`->B.end();\n"
	excode "else\n"
	excode "--`0`->I;\n"
end func

func[__any, __rme, __raw, repeat]_repeat(me_: int, type: []int, len: int): int
	if(dbg)
		if(len < 0)
			throw 0xE9170006
		end if
	end if
	excode "using TI_=decltype(*`0`->B);\n"
	excode "type_(Array_<TI_>)r_=new_(Array_<TI_>)();\n"
	excode "r_->L=`0`->L*`2`;\n"
	excode "r_->B=newPrimArray_(static_cast<std::size_t>(r_->L+bufLen_<TI_>()),TI_);\n"
	excode "for(int64_t i_=0;i_<`2`;i_++){\n"
	excode "for(int64_t j_=0;j_<`0`->L;j_++)r_->B[i_*`0`->L+j_]=`0`->B[j_];\n"
	excode "}\n"
	excode "if(bufLen_<TI_>()>0)r_->B[r_->L]=0;\n"
	excode "return r_;\n"
end func

func _replace(me_: []char, old: []char, new: []char): []char
	if(^old=0)
		ret me_
	end if
	var r: []char :: ""
	var p: int :: 0
	while loop(p < ^me_)
		var p2: int :: me_.findStr(old, p)
		if(p2 = -1)
			do r :~ me_.sub(p, -1)
			break loop
		end if
		do r :~ me_.sub(p, p2 - p) ~ new
		do p :: p2 + ^old
	end while
	ret r
end func

func[__any]_reverse(me_: int, type: []int)
	excode "reverse_(`0`);\n"
end func

func[__any, __rme]_sar(me_: int, type: []int, n: int): int
	if(dbg)
		excode "if(`2`<0||`2`>=sizeof(`0`)*8)throw 0xe9170006;\n"
	end if
	excode "return sar_(`0`,`2`);\n"
end func

func[__any]_setPtr(me_: int, type: []int, ptr: @ListPtr)
	excode "auto l_=reinterpret_cast<listPtr_<decltype(`0`->B)>*>(`2`->`.ptr`);\n"
	excode "`0`->I=l_->I;\n"
end func

func[__any, __rme]_shl(me_: int, type: []int, n: int): int
	if(dbg)
		excode "if(`2`<0||`2`>=sizeof(`0`)*8)throw 0xe9170006;\n"
	end if
	excode "return `0`<<`2`;\n"
end func

func[__any, __rme]_shr(me_: int, type: []int, n: int): int
	if(dbg)
		excode "if(`2`<0||`2`>=sizeof(`0`)*8)throw 0xe9170006;\n"
	end if
	excode "return `0`>>`2`;\n"
end func

func _signFloat(me_: float): float
	ret me_ > 0.0 ?(1.0, me_ < 0.0 ?(-1.0, 0.0))
end func

func _signInt(me_: int): int
	ret me_ > 0 ?(1, me_ < 0 ?(-1, 0))
end func

func[__any]_sort(me_: int, type: []int)
	excode "sort_(`0`);\n"
end func

func _split(me_: []char, delimiter: []char): [][]char
	if(dbg)
		if(^delimiter = 0)
			throw 0xE9170006
		end if
	end if
	var result: list<[]char> :: #list<[]char>
	var p: int :: 0
	while(true)
		var p2: int :: me_.findStr(delimiter, p)
		if(p2 = -1)
			do result.add(me_.sub(p, -1))
			ret result.toArray()
		end if
		do result.add(me_.sub(p, p2 - p))
		do p :: p2 + ^delimiter
	end while
end func

func[__any, __rme]_sub(me_: int, type: []int, start: int, len: int): int
	excode "return sub_(`0`,`2`,`3`);\n"
end func

func[__any]_tail(me_: int, type: []int)
	excode "`0`->I=`0`->B.end();\n"
	excode "if(`0`->B.size()!=0)\n"
	excode "--`0`->I;\n"
end func

func[__any]_term(me_: int, type: []int): bool
	excode "return `0`->I==`0`->B.end();\n"
end func

func[__any]_termOffset(me_: int, type: []int, offset: int): bool
	excode "auto p_=`0`->I;\n"
	excode "if(p_==`0`->B.end())return true;\n"
	excode "if(`2`>=0){\n"
	excode "for(int64_t i_=0;i_<`2`;i_++){\n"
	excode "++p_;\n"
	excode "if(p_==`0`->B.end())return true;\n"
	excode "}\n"
	excode "}else{\n"
	excode "for(int64_t i_=0;i_>`2`;i_--){\n"
	excode "if(`0`->I==`0`->B.begin())`0`->I=`0`->B.end();else --`0`->I;\n"
	excode "if(p_==`0`->B.end())return true;\n"
	excode "}\n"
	excode "}\n"
	excode "return false;\n"
end func

func[__any, __rac]_toArray(me_: int, type: []int): int
	excode "return toArray_<C_>(`0`);"
end func

func[__any, __rak]_toArrayKey(me_: int, type: []int): int
	; TODO:
end func

func[__any, __rav]_toArrayValue(me_: int, type: []int): int
	; TODO:
end func

func _toBit64(me_: []char, success: &bool): bit64
	excode "std::u16string s_=`0`->B;\n"
	excode "const std::string&t_=utf16ToUtf8_(s_);\n"
	excode "try{\n"
	excode "std::size_t s_;\n"
	excode "uint64_t v_=t_.size()>2&&t_[0]=='0'&&t_[1]=='x'?std::stoull(t_,&s_,16):std::stoull(t_,&s_);\n"
	excode "if(s_==t_.size()){\n"
	excode "*`1`=true;\n"
	excode "return v_;\n"
	excode "}else{\n"
	excode "*`1`=false;\n"
	excode "return 0;\n"
	excode "}\n"
	excode "}catch(...){\n"
	excode "*`1`=false;\n"
	excode "return 0;\n"
	excode "}\n"
end func

func _toFloat(me_: []char, success: &bool): float
	excode "std::u16string s_=`0`->B;\n"
	excode "const std::string&t_=utf16ToUtf8_(s_);\n"
	excode "try{\n"
	excode "std::size_t s_;\n"
	excode "double v_=std::stod(t_,&s_);\n"
	excode "if(s_==t_.size()){\n"
	excode "*`1`=true;\n"
	excode "return v_;\n"
	excode "}else{\n"
	excode "*`1`=false;\n"
	excode "return 0;\n"
	excode "}\n"
	excode "}catch(...){\n"
	excode "*`1`=false;\n"
	excode "return 0;\n"
	excode "}\n"
end func

func _toInt(me_: []char, success: &bool): int
	excode "std::u16string s_=`0`->B;\n"
	excode "const std::string&t_=utf16ToUtf8_(s_);\n"
	excode "try{\n"
	excode "std::size_t s_;\n"
	excode "int64_t v_=t_.size()>2&&t_[0]=='0'&&t_[1]=='x'?std::stoll(t_,&s_,16):std::stoull(t_,&s_);\n"
	excode "if(s_==t_.size()){\n"
	excode "*`1`=true;\n"
	excode "return v_;\n"
	excode "}else{\n"
	excode "*`1`=false;\n"
	excode "return 0;\n"
	excode "}\n"
	excode "}catch(...){\n"
	excode "*`1`=false;\n"
	excode "return 0;\n"
	excode "}\n"
end func

func[__any]_toStr(me_: int, type: []int): []char
	excode "return toStr_(`0`);\n"
end func

func _toStrFmtFloat(me_: float, fmt: []char): []char
	; TODO:
end func

func _toStrFmtInt(me_: int, fmt: []char): []char
	; TODO:
end func

func _trim(me_: []char): []char
	var f: int :: -1
	for i(0, ^me_ - 1)
		var c: bit64 :: me_[i] $ bit64
		if(!(c <= 0x20b64 | c = 0xA0b64))
			do f :: i
			break i
		end if
	end for
	if(f = -1)
		ret me_
	end if
	var l: int :: -1
	for i(^me_ - 1, 0, -1)
		var c: bit64 :: me_[i] $ bit64
		if(!(c <= 0x20b64 | c = 0xA0b64))
			do l :: i
			break i
		end if
	end for
	var r: []char :: #[l - f + 1]char
	for i(0, l - f)
		do r[i] :: me_[f + i]
	end for
	ret r
end func

func _trimLeft(me_: []char): []char
	var f: int :: -1
	for i(0, ^me_ - 1)
		var c: bit64 :: me_[i] $ bit64
		if(!(c <= 0x20b64 | c = 0xA0b64))
			do f :: i
			break i
		end if
	end for
	if(f = -1)
		ret me_
	end if
	var r: []char :: #[^me_ - f]char
	for i(0, ^me_ - f - 1)
		do r[i] :: me_[f + i]
	end for
	ret r
end func

func _trimRight(me_: []char): []char
	var l: int :: -1
	for i(^me_ - 1, 0, -1)
		var c: bit64 :: me_[i] $ bit64
		if(!(c <= 0x20b64 | c = 0xA0b64))
			do l :: i
			break i
		end if
	end for
	if(l = -1)
		ret me_
	end if
	var r: []char :: #[l + 1]char
	for i(0, l)
		do r[i] :: me_[i]
	end for
	ret r
end func

func _upper(me_: []char): []char
	var s: []char :: #[^me_]char
	for i(0, ^me_ - 1)
		if('a' <= me_[i] & me_[i] <= 'z')
			do s[i] :: (me_[i] $ bit64 - 0x61b64 + 0x41b64) $ char
		else
			do s[i] :: me_[i]
		end if
	end for
	ret s
end func

func[__any, __tme, __rme]_xor(me_: int, type: []int, n: int): int
	excode "return `0`^`2`;\n"
end func
