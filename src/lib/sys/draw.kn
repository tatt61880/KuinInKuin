#exe,web
+const white: int :: 0xFFFFFFFF
+const black: int :: 0xFF000000
#web
+var cur: web@Draw
#exe,web

#exe
func[d0001.knd, _drawInit]_init()
end func
#web
func _init()
	do web@initFunc :: @initDraw
end func
#exe,web

#exe
func[d0001.knd, _drawFin]_fin()
end func

+enum AlignHorizontal
	left
	center
	right
end enum

+enum AlignVertical
	top
	center
	bottom
end enum

#exe,web
+enum Blend
	none
	alpha
	add
	sub
	mul
	exclusion
end enum

#exe
+class Font()
	*func[__ndc]ctor()
	end func
	
	*func[__frc]_dtor()
		do me.fin()
	end func
	
	+func[d0001.knd, _fontAlign]align(horizontal: @AlignHorizontal, vertical: @AlignVertical)
	end func
	
	+func[d0001.knd, _fontCalcSize]calcSize(width: &float, height: &float, text: []char)
	end func
	
	+func[d0001.knd, _fontCalcWidth]calcWidth(text: []char): float
	end func
	
	+func[d0001.knd, _fontDraw]draw(dstX: float, dstY: float, text: []char, color: int)
	end func
	
	+func[d0001.knd, _fontDrawScale]drawScale(dstX: float, dstY: float, dstScaleX: float, dstScaleY: float, text: []char, color: int)
	end func
	
	+func[d0001.knd, _fontFin]fin()
	end func
	
	+func[d0001.knd, _fontGetHeight]getHeight(): float
	end func
	
	+func[d0001.knd, _fontHandle]handle(): int
	end func
	
	+func[d0001.knd, _fontMaxHeight]maxHeight(): float
	end func
	
	+func[d0001.knd, _fontMaxWidth]maxWidth(): float
	end func
	
	+func[d0001.knd, _fontSetHeight]setHeight(height: float)
	end func
	
	var tex: int
	var view: int
	var cellSize: int
	var cellSizeAligned: int
	var advance: float
	var height: float
	var proportional: int
	var font: int
	var charMap: int
	var cntMap: int
	var pixel: int
	var bitmap: int
	var dc: int
	var glyphWidth: int
end class

+class Obj()
	*func[__ndc]ctor()
	end func
	
	*func[__frc]_dtor()
		do me.fin()
	end func
	
	+func[d0001.knd, _objDraw, _5]draw(element: int, frame: float, diffuse: @Tex, specular: @Tex, normal: @Tex)
	end func
	
	+func[d0001.knd, _objDrawFlat, _5]drawFlat(element: int, frame: float, diffuse: @Tex)
	end func
	
	+func[d0001.knd, _objDrawOutline, _6]drawOutline(element: int, frame: float, width: float, color: int)
	end func
	
	+func[d0001.knd, _objDrawToon, _5]drawToon(element: int, frame: float, diffuse: @Tex, specular: @Tex, normal: @Tex)
	end func
	
	+func[d0001.knd, _objDrawToonWithShadow, _5]drawToonWithShadow(element: int, frame: float, diffuse: @Tex, specular: @Tex, normal: @Tex, shadow: @Shadow)
	end func
	
	+func[d0001.knd, _objDrawWithShadow, _5]drawWithShadow(element: int, frame: float, diffuse: @Tex, specular: @Tex, normal: @Tex, shadow: @Shadow)
	end func
	
	+func[d0001.knd, _objFin]fin()
	end func
	
	+func[d0001.knd, _objLook]look(x: float, y: float, z: float, atX: float, atY: float, atZ: float, upX: float, upY: float, upZ: float, fixUp: bool)
	end func
	
	+func[d0001.knd, _objLookCamera]lookCamera(x: float, y: float, z: float, upX: float, upY: float, upZ: float, fixUp: bool)
	end func
	
	+func[d0001.knd, _objMat]mat(mat_: []float, normMat: []float)
	end func
	
	+func[d0001.knd, _objPos]pos(scaleX: float, scaleY: float, scaleZ: float, rotX: float, rotY: float, rotZ: float, transX: float, transY: float, transZ: float)
	end func
	
	var elementNum: int
	var elementKinds: int
	var elements: int
	var mat1: int
	var mat2: int
	var mat3: int
	var mat4: int
	var mat5: int
	var mat6: int
	var mat7: int
	var mat8: int
	var normMat1: int
	var normMat2: int
	var normMat3: int
	var normMat4: int
	var normMat5: int
	var normMat6: int
	var normMat7: int
	var normMat8: int
end class

+class Particle()
	*func[__ndc]ctor()
	end func
	
	*func[__frc]_dtor()
		do me.fin()
	end func
	
	+func[d0001.knd, _particleDraw]draw(tex: @Tex)
	end func
	
	+func[d0001.knd, _particleDraw2d]draw2d(tex: @Tex)
	end func
	
	+func[d0001.knd, _particleEmit]emit(x: float, y: float, z: float, veloX: float, veloY: float, veloZ: float, size: float, sizeVelo: float, rot: float, rotVelo: float)
	end func
	
	+func[d0001.knd, _particleFin]fin()
	end func
	
	var lifespan: int
	var buf1: int
	var buf2: int
	var buf3: int
	var buf4: int
	var buf5: int
	var buf6: int
	var buf7: int
	var buf8: int
	var particlePtr: int
	var texSet: int
	var texTmp: int
	var draw1To2: int
end class

+enum Sampler
	point
	linear
end enum

+class Shadow()
	*func[__ndc]ctor()
	end func
	
	*func[__frc]_dtor()
		do me.fin()
	end func
	
	+func[d0001.knd, _shadowAdd]add(obj: @Obj, element: int, frame: float)
	end func
	
	+func[d0001.knd, _shadowBeginRecord]beginRecord(x: float, y: float, z: float, radius: float)
	end func
	
	+func[d0001.knd, _shadowEndRecord]endRecord()
	end func
	
	+func[d0001.knd, _shadowFin]fin()
	end func
	
	var depthTex: int
	var depthView: int
	var depthResView: int
	var depthSize: int
	var shadowProjView: int
end class

+class Tex()
	*func[__ndc]ctor()
	end func
	
	*func[__frc]_dtor()
		do me.fin()
	end func
	
	+func[d0001.knd, _texDraw]draw(dstX: float, dstY: float, srcX: float, srcY: float, srcW: float, srcH: float, color: int)
	end func
	
	+func[d0001.knd, _texDrawRot]drawRot(dstX: float, dstY: float, dstW: float, dstH: float, srcX: float, srcY: float, srcW: float, srcH: float, centerX: float, centerY: float, angle: float, color: int)
	end func
	
	+func[d0001.knd, _texDrawScale]drawScale(dstX: float, dstY: float, dstW: float, dstH: float, srcX: float, srcY: float, srcW: float, srcH: float, color: int)
	end func
	
	+func[d0001.knd, _texFin]fin()
	end func
	
	+func[d0001.knd, _texHeight]height(): int
	end func
	
	+func[d0001.knd, _texImgHeight]imgHeight(): int
	end func
	
	+func[d0001.knd, _texImgWidth]imgWidth(): int
	end func
	
	+func[d0001.knd, _texWidth]width(): int
	end func
	
	var size: int
	var imgSize: int
	var tex: int
	var view: int
end class

+func[d0001.knd, _ambLight]ambLight(topR: float, topG: float, topB: float, bottomR: float, bottomG: float, bottomB: float)
end func

+func[d0001.knd, _argbToColor]argbToColor(a: float, r: float, g: float, b: float): int
end func

+func[d0001.knd, _autoClear]autoClear(enabled: bool)
end func

#exe
+func[d0001.knd, _blend]blend(kind: @Blend)
end func
#web
func blend(kind: @Blend)
	do impl(@cur, kind)
	func impl(cur: web@Draw, kind:@Blend)
		switch(kind)
		case %none
			excode "`0`.`.gl`.disable(`0`.`.gl`.BLEND);\n"
		case %alpha
			excode "`0`.`.gl`.enable(`0`.`.gl`.BLEND);\n"
			excode "`0`.`.gl`.blendFuncSeparate(`0`.`.gl`.SRC_ALPHA,`0`.`.gl`.ONE_MINUS_SRC_ALPHA,`0`.`.gl`.ONE,`0`.`.gl`.ONE_MINUS_SRC_ALPHA);\n"
			excode "`0`.`.gl`.blendEquation(`0`.`.gl`.FUNC_ADD);\n"
		case %add
			excode "`0`.`.gl`.enable(`0`.`.gl`.BLEND);\n"
			excode "`0`.`.gl`.blendFuncSeparate(`0`.`.gl`.SRC_ALPHA,`0`.`.gl`.ONE,`0`.`.gl`.ONE,`0`.`.gl`.ONE_MINUS_SRC_ALPHA);\n"
			excode "`0`.`.gl`.blendEquation(`0`.`.gl`.FUNC_ADD);\n"
		case %sub
			excode "`0`.`.gl`.enable(`0`.`.gl`.BLEND);\n"
			excode "`0`.`.gl`.blendFuncSeparate(`0`.`.gl`.SRC_ALPHA,`0`.`.gl`.ONE,`0`.`.gl`.ONE,`0`.`.gl`.ONE_MINUS_SRC_ALPHA);\n"
			excode "`0`.`.gl`.blendEquation(`0`.`.gl`.FUNC_SUBTRACT);\n"
		case %mul
			excode "`0`.`.gl`.enable(`0`.`.gl`.BLEND);\n"
			excode "`0`.`.gl`.blendFuncSeparate(`0`.`.gl`.DST_COLOR,`0`.`.gl`.ZERO,`0`.`.gl`.ONE,`0`.`.gl`.ONE_MINUS_SRC_ALPHA);\n"
			excode "`0`.`.gl`.blendEquation(`0`.`.gl`.FUNC_ADD);\n"
		case %exclusion
			excode "`0`.`.gl`.enable(`0`.`.gl`.BLEND);\n"
			excode "`0`.`.gl`.blendFuncSeparate(`0`.`.gl`.ONE_MINUS_DST_COLOR,`0`.`.gl`.ONE_MINUS_SRC_COLOR,`0`.`.gl`.ONE,`0`.`.gl`.ONE_MINUS_SRC_ALPHA);\n"
			excode "`0`.`.gl`.blendEquation(`0`.`.gl`.FUNC_ADD);\n"
		end switch
	end func
end func
#exe,web

#exe
+func[d0001.knd, _camera]camera(eyeX: float, eyeY: float, eyeZ: float, atX: float, atY: float, atZ: float, upX: float, upY: float, upZ: float)
end func

+func[d0001.knd, _capture]capture(path: []char): bool
end func

+func[d0001.knd, _circle, _1]circle(x: float, y: float, radiusX: float, radiusY: float, color: int)
end func

+func[d0001.knd, _circleLine, _1]circleLine(x: float, y: float, radiusX: float, radiusY: float, color: int)
end func

#exe
+func[d0001.knd, _clear]clear()
#web
+func clear()
	do impl(@cur)
	func impl(cur: web@Draw)
		excode "`0`.`.gl`.clear(`0`.`.gl`.COLOR_BUFFER_BIT);\n"
	end func
#exe,web
end func

#exe
+func[d0001.knd, _clearColor]clearColor(color: int)
#web
+func clearColor(color: int)
	var a: float
	var r: float
	var g: float
	var b: float
	do @splitColor(&a, &r, &g, &b, color)
	do impl(@cur, a, r, g, b)
	func impl(cur: web@Draw, a: float, r: float, g: float, b: float)
		excode "`0`.`.gl`.clearColor(`2`,`3`,`4`,`1`);\n"
	end func
#exe,web
end func

#exe
+func[d0001.knd, _cnt]cnt(): int
end func

+func[d0001.knd, _colorToArgb]colorToArgb(a: &float, r: &float, g: &float, b: &float, color: int)
end func

+func[d0001.knd, _depth]depth(test: bool, write: bool)
end func

+func[d0001.knd, _dirLight]dirLight(atX: float, atY: float, atZ: float, r: float, g: float, b: float)
end func

+func[d0001.knd, _editPixels]editPixels(callback: func<(int, int, []bit32)>)
end func

+func[d0001.knd, _filterMonotone, _2]filterMonotone(color: int, rate: float)
end func

+func[d0001.knd, _filterNone]filterNone()
end func

+func[d0001.knd, _line]line(x1: float, y1: float, x2: float, y2: float, color: int)
end func

+func[d0001.knd, _makeBox, __mki]makeBox(me2: @Obj): @Obj
end func

+func[d0001.knd, _makeFont, __mki]makeFont(me2: @Font, fontName: []char, size: int, bold: bool, italic: bool, proportional: bool, advance: float): @Font
end func

+func makeObj(path: []char): @Obj
	var f: file@Reader :: file@makeReader(path)
	if(f =& null)
		ret null
	end if
	var d: []bit8 :: f.read(f.fileSize())
	do f.fin()
	ret makeObjImpl(d)
	
	func[d0001.knd, _makeObj, __mki]makeObjImpl(me2: @Obj, data: []bit8): @Obj
	end func
end func

+func[d0001.knd, _makeParticle, __mki, _3]makeParticle(me2: @Particle, lifeSpan: int, color1: int, color2: int, friction: float, accelX: float, accelY: float, accelZ: float, sizeAccel: float, rotAccel: float): @Particle
end func

+func[d0001.knd, _makePlane, __mki]makePlane(me2: @Obj): @Obj
end func

+func[d0001.knd, _makeShadow, __mki, _5]makeShadow(me2: @Shadow, width: int, height: int): @Shadow
end func

+func[d0001.knd, _makeSphere, __mki]makeSphere(me2: @Obj): @Obj
end func

+func makeTex(path: []char): @Tex
	var f: file@Reader :: file@makeReader(path)
	if(f =& null)
		ret null
	end if
	var d: []bit8 :: f.read(f.fileSize())
	do f.fin()
	ret makeTexImpl(d, path)
	
	func[d0001.knd, _makeTex, __mki]makeTexImpl(me2: @Tex, data: []bit8, path: []char): @Tex
	end func
end func

+func makeTexArgb(path: []char): @Tex
	var f: file@Reader :: file@makeReader(path)
	if(f =& null)
		ret null
	end if
	var d: []bit8 :: f.read(f.fileSize())
	do f.fin()
	ret makeTexArgbImpl(d, path)
	
	func[d0001.knd, _makeTexArgb, __mki]makeTexArgbImpl(me2: @Tex, data: []bit8, path: []char): @Tex
	end func
end func

+func[d0001.knd, _makeTexEvenArgb, __mki]makeTexEvenArgb(me2: @Tex, a: float, r: float, g: float, b: float): @Tex
end func

+func[d0001.knd, _makeTexEvenColor, __mki]makeTexEvenColor(me2: @Tex, color: int): @Tex
end func

+func[d0001.knd, _proj]proj(fovy: float, aspectX: float, aspectY: float, nearZ: float, farZ: float)
end func

#exe
+func[d0001.knd, _rect]rect(x: float, y: float, width: float, height: float, color: int)
end func
#web
+func rect(x: float, y: float, width: float, height: float, color: int)
	var a: float
	var r: float
	var g: float
	var b: float
	do @splitColor(&a, &r, &g, &b, color)
	do impl(@cur, x, y, width, height, a, r, g, b)
	func impl(cur: web@Draw, x: float, y: float, width: float, height: float, a: float, r: float, g: float, b: float)
		excode "`0`.`.gl`.useProgram(`0`.`.rectShader`);\n"
		excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ARRAY_BUFFER,`0`.`.rectVertex`);\n"
		excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,`0`.`.rectIdx`);\n"
		excode "`0`.`.gl`.enableVertexAttribArray(`0`.`.rectVertexSlot`);\n"
		excode "`0`.`.gl`.vertexAttribPointer(`0`.`.rectVertexSlot`,2,`0`.`.gl`.FLOAT,false,0,0);\n"
		excode "`0`.`.gl`.uniform4f(`0`.`.rectVecsSlot`,`1`,`2`,`3`,`4`);\n"
		excode "`0`.`.gl`.uniform4f(`0`.`.rectColorSlot`,`6`,`7`,`8`,`5`);\n"
		excode "`0`.`.gl`.drawElements(`0`.`.gl`.TRIANGLES,6,`0`.`.gl`.UNSIGNED_SHORT,0);\n"
		excode "`0`.`.gl`.disableVertexAttribArray(`0`.`.rectVertexSlot`);\n"
		excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ARRAY_BUFFER,null);\n"
		excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,null);\n"
	end func
end func
#exe,web

#exe
+func[d0001.knd, _rectLine]rectLine(x: float, y: float, width: float, height: float, color: int)
end func

+func[d0001.knd, _render]render(fps: int)
end func

+func[d0001.knd, _sampler]sampler(kind: @Sampler)
end func

+func[d0001.knd, _screenHeight]screenHeight(): int
end func

+func[d0001.knd, _screenWidth]screenWidth(): int
end func

#exe
+func[d0001.knd, _target]target(drawCtrl: wnd@Draw)
end func
#web
+func target(drawTag: web@Draw)
	do @cur :: drawTag
end func
#exe

#exe
+func[d0001.knd, _tri]tri(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, color: int)
end func
#web
+func tri(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, color: int)
	var a: float
	var r: float
	var g: float
	var b: float
	do @splitColor(&a, &r, &g, &b, color)
	do impl(@cur, x1, y1, x2, y2, x3, y3, a, r, g, b)
	func impl(cur: web@Draw, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, a: float, r: float, g: float, b: float)
		excode "`0`.`.gl`.useProgram(`0`.`.triShader`);\n"
		excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ARRAY_BUFFER,`0`.`.triVertex`);\n"
		excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,`0`.`.triIdx`);\n"
		excode "`0`.`.gl`.enableVertexAttribArray(`0`.`.triVertexSlot`);\n"
		excode "`0`.`.gl`.vertexAttribPointer(`0`.`.triVertexSlot`,3,`0`.`.gl`.FLOAT,false,0,0);\n"
		excode "`0`.`.gl`.uniform4f(`0`.`.triVecs0Slot`,`1`,`2`,`3`,`4`);\n"
		excode "`0`.`.gl`.uniform2f(`0`.`.triVecs1Slot`,`5`,`6`);\n"
		excode "`0`.`.gl`.uniform4f(`0`.`.triColorSlot`,`8`,`9`,`10`,`7`);\n"
		excode "`0`.`.gl`.drawElements(`0`.`.gl`.TRIANGLES,3,`0`.`.gl`.UNSIGNED_SHORT,0);\n"
		excode "`0`.`.gl`.disableVertexAttribArray(`0`.`.triVertexSlot`);\n"
		excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ARRAY_BUFFER,null);\n"
		excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,null);\n"
	end func
end func

+func splitColor(a: &float, r: &float, g: &float, b: &float, color: int)
	var n: bit64 :: color $ bit64
	do a :: n.shr(24).and(255b64) $ float / 255.0
	do r :: n.shr(16).and(255b64) $ float / 255.0
	do g :: n.shr(8).and(255b64) $ float / 255.0
	do b :: n.and(255b64) $ float / 255.0
end func

func initDraw(draw: web@Draw)
	excode "`0`.`.gl`=`0`.`.obj`.getContext(\"webgl\")||c.getContext(\"experimental-webgl\");\n"
	excode "`0`.`.gl`.clearColor(0.0,0.0,0.0,1.0);\n"
	
	excode "let triVs_=`0`.`.gl`.createShader(`0`.`.gl`.VERTEX_SHADER);\n"
	excode "`0`.`.gl`.shaderSource(triVs_,\""
	excode "attribute vec3 weight;"
	excode "uniform vec4 vecs0;"
	excode "uniform vec2 vecs1;"
	excode "void main(){"
	excode "gl_Position.xy=vecs0.rg*weight.r+vecs0.ba*weight.g+vecs1.rg*weight.b;"
	excode "gl_Position.z=0.0;"
	excode "gl_Position.w=1.0;"
	excode "}\");\n"
	excode "`0`.`.gl`.compileShader(triVs_);\n"

	excode "let triPs_=`0`.`.gl`.createShader(`0`.`.gl`.FRAGMENT_SHADER);\n"
	excode "`0`.`.gl`.shaderSource(triPs_,\""
	excode "precision mediump float;"
	excode "uniform vec4 color;"
	excode "void main(){"
	excode "gl_FragColor=vec4(color.r,color.g,color.b,color.a);"
	excode "}\");\n"
	excode "`0`.`.gl`.compileShader(triPs_);\n"
	
	excode "`0`.`.triShader`=`0`.`.gl`.createProgram();\n"
	excode "`0`.`.gl`.attachShader(`0`.`.triShader`,triVs_);\n"
	excode "`0`.`.gl`.attachShader(`0`.`.triShader`,triPs_);\n"
	excode "`0`.`.gl`.linkProgram(`0`.`.triShader`);\n"
	
	excode "`0`.`.triVertex`=`0`.`.gl`.createBuffer();\n"
	excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ARRAY_BUFFER,`0`.`.triVertex`);\n"
	excode "`0`.`.gl`.bufferData(`0`.`.gl`.ARRAY_BUFFER,new Float32Array([1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0]),`0`.`.gl`.STATIC_DRAW);\n"
	excode "`0`.`.triIdx`=`0`.`.gl`.createBuffer();\n"
	excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,`0`.`.triIdx`);\n"
	excode "`0`.`.gl`.bufferData(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,new Int16Array([0,1,2]),`0`.`.gl`.STATIC_DRAW);\n"
	excode "`0`.`.triVertexSlot`=`0`.`.gl`.getAttribLocation(`0`.`.triShader`,\"weight\");\n"
	excode "`0`.`.triVecs0Slot`=`0`.`.gl`.getUniformLocation(`0`.`.triShader`,\"vecs0\");\n"
	excode "`0`.`.triVecs1Slot`=`0`.`.gl`.getUniformLocation(`0`.`.triShader`,\"vecs1\");\n"
	excode "`0`.`.triColorSlot`=`0`.`.gl`.getUniformLocation(`0`.`.triShader`,\"color\");\n"
	
	excode "let rectVs_=`0`.`.gl`.createShader(`0`.`.gl`.VERTEX_SHADER);\n"
	excode "`0`.`.gl`.shaderSource(rectVs_,\""
	excode "attribute vec2 weight;"
	excode "uniform vec4 vecs;"
	excode "void main(){"
	excode "gl_Position.xy=vecs.rg+vecs.ba*weight;"
	excode "gl_Position.z=0.0;"
	excode "gl_Position.w=1.0;"
	excode "}\");\n"
	excode "`0`.`.gl`.compileShader(rectVs_);\n"
	
	excode "`0`.`.rectShader`=`0`.`.gl`.createProgram();\n"
	excode "`0`.`.gl`.attachShader(`0`.`.rectShader`,rectVs_);\n"
	excode "`0`.`.gl`.attachShader(`0`.`.rectShader`,triPs_);\n"
	excode "`0`.`.gl`.linkProgram(`0`.`.rectShader`);\n"
	
	excode "`0`.`.rectVertex`=`0`.`.gl`.createBuffer();\n"
	excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ARRAY_BUFFER,`0`.`.rectVertex`);\n"
	excode "`0`.`.gl`.bufferData(`0`.`.gl`.ARRAY_BUFFER,new Float32Array([0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0]),`0`.`.gl`.STATIC_DRAW);\n"
	excode "`0`.`.rectIdx`=`0`.`.gl`.createBuffer();\n"
	excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,`0`.`.rectIdx`);\n"
	excode "`0`.`.gl`.bufferData(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,new Int16Array([0,1,2,3,2,1]),`0`.`.gl`.STATIC_DRAW);\n"
	excode "`0`.`.rectVertexSlot`=`0`.`.gl`.getAttribLocation(`0`.`.rectShader`,\"weight\");\n"
	excode "`0`.`.rectVecsSlot`=`0`.`.gl`.getUniformLocation(`0`.`.rectShader`,\"vecs\");\n"
	excode "`0`.`.rectColorSlot`=`0`.`.gl`.getUniformLocation(`0`.`.rectShader`,\"color\");\n"
	
	excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ARRAY_BUFFER,null);\n"
	excode "`0`.`.gl`.bindBuffer(`0`.`.gl`.ELEMENT_ARRAY_BUFFER,null);\n"
	do @target(draw)
	do @blend(%alpha)
end func
